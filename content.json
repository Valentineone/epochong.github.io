{"meta":{"title":"epochong","subtitle":null,"description":null,"author":"epochong","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-05-14T04:31:56.000Z","updated":"2019-05-14T04:31:56.791Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-05-14T04:32:24.000Z","updated":"2019-05-14T06:21:18.208Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-05-14T04:32:10.000Z","updated":"2019-05-14T06:48:12.313Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"guestbook","date":"2019-05-14T04:32:39.000Z","updated":"2019-05-14T04:32:39.229Z","comments":true,"path":"guestbook/index.html","permalink":"http://yoursite.com/guestbook/index.html","excerpt":"","text":""}],"posts":[{"title":"使用hexo搭建个人博客","slug":"hexo-yalia","date":"2019-05-10T16:00:00.000Z","updated":"2019-05-14T07:06:46.487Z","comments":true,"path":"2019/05/11/hexo-yalia/","link":"","permalink":"http://yoursite.com/2019/05/11/hexo-yalia/","excerpt":"","text":"准备工作安装hexo 由于使用国外镜像会很慢 可用 get 命令查看 registry 1npm congfig get registry 原版结果为 1http://registry.npmjs.org 用 set 命令换成阿里的镜像就可以了 1npm config set registry http://registry.npm.taobao.org 然后使用(以后的直接将npm换成cnpm下载就会很快) 1cnpm install -g hexo-cli 我的15.29s就安装完成了，如果使用国外镜像，反正我等了很长时间还是没有下载完 当然你想使用国外镜像也行直接 1npm install -g hexo-cli 正式开始先建一个blog文件夹所有hexo操作都在这里面进行 然后命令行进入blog文件夹下初始化1hexo init 启动命令(预览)123hexo shexo starthexo server 这一步下来就可以看到自己博客地址了，输入到浏览器就可以查看预生成的博客 新建一篇文章1hexo n &quot;first bolg&quot; 清理1hexo clear 生成12hexo gg(general) 然后新建的博客就被归档 将博客部署到远端(GitHub)打开GitHub新建一个仓库仓库命名必须是 1你的github用户名.github.io ==如果不是这个命名，在最后执行hexo d将博客部署到github上输入网址时会出现404== 后期直接在浏览器输入地址就可以访问 安装插件1cnpm install --save hexo -deployer-git 不用理会WARNING 设置_config.yml相关内容使用windows命令行命令打开该文件 1start _confing.yml 然后在文件末尾添加内容 1234deploy: type: git repo: https://github.com/Valentineone/epochong.github.io.git branch: master 部署到仓库1hexo d 这个时候cmd窗口底部会出现 1Branch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;git@github.com:epochong/epochong.github.io.git&apos;. 说明已经部署成功 访问自己的博客在网站中输入你刚才建的仓库的名称 1yourusername.github.io 即可访问你的博客==如果此时出现网页访问404问题==是因为你新建的仓库名不是你的github账号的用户名 解决方法 一种是修改github的username名称和你新建的存储库.github前的名称相同 一种是重新建立一个 你的github账号username.github.io 两种方法完成后重新执行1hexo d 刷新网页就能看到你建的博客了 设置喜欢的主题在下面的网站上clone到本地1https://github.com/litten/hexo-theme-yilia 命令行clone1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 克隆到本地themes文件夹下 修改_config.yml中theme参数1theme: yilia 清理生成加打开服务123hexo cleanhexo ghexo s 这个时候4000的地址的博客已经换了主题 推到远端1hexo d 刷新你的博客主题设置完成","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"markdown常用语法","slug":"Markdown语法","date":"2019-05-10T16:00:00.000Z","updated":"2019-05-14T06:56:07.428Z","comments":true,"path":"2019/05/11/Markdown语法/","link":"","permalink":"http://yoursite.com/2019/05/11/Markdown语法/","excerpt":"","text":"添加图片1![图片描述](图片地址) 超链接1[baidu](网址) 斜体1*斜体* 粗体1**粗体** 字体123456&lt;p&gt;&lt;/p&gt;标签&lt;font&gt;&lt;/font&gt;标签algn:设置对齐方式face:设置字体color:设置字体颜色size:设置字体大小 字体、颜色和字号","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}]},{"title":"first blog","slug":"first-blog","date":"2019-05-06T12:47:39.000Z","updated":"2019-05-14T07:06:50.713Z","comments":true,"path":"2019/05/06/first-blog/","link":"","permalink":"http://yoursite.com/2019/05/06/first-blog/","excerpt":"","text":"","categories":[],"tags":[{"name":"杂记","slug":"杂记","permalink":"http://yoursite.com/tags/杂记/"}]},{"title":"计蒜客 队列 敲7","slug":"计蒜客 队列 敲7","date":"2019-05-03T10:50:44.000Z","updated":"2019-05-14T06:57:10.023Z","comments":true,"path":"2019/05/03/计蒜客 队列 敲7/","link":"","permalink":"http://yoursite.com/2019/05/03/计蒜客 队列 敲7/","excerpt":"","text":"版权声明：wangchong https://blog.csdn.net/wfcn_zyq/article/details/89790238 1时间限制：1000ms 空间限制：131072K 有一种酒桌游戏叫做 “敲 7”，规则是从一个人开始，说出任意数字，其他人会顺序往后报，如果一个数字包含 77，或者是 77 的倍数，那么需要敲打杯子或盘子，不能说出。 现在 nn 个人围坐在一个圆桌周围，他们编号从 11 到 nn 顺时针排列。从某一人开始报出一个数字，其他人会按照顺时针方向顺序往后报 (加一)，如果某个人的数字包含 77，或者是 77 的倍数，那么他将退出游戏，下一个人继续接着报，直到剩一个人为止。 输入格式 第一行输入三个整数，nn，mm，tt。nn 代表总人数，mm 代表从第 mm 个人开始报数，他报出的数字是 tt。（1 \\leq m \\leq n \\leq 10001≤m≤n≤1000，1 \\leq t \\leq 1001≤t≤100）接下来的 nn 行，每一行输入一个字符串，代表这 nn 个人的名字，字符串的长度不超过 2020。 输出格式 输出剩下的那个人的名字，占一行。 样例输入 1234565 3 20donglalinanlalixilalibeilalichuanpu 样例输出 1chuanpu 实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package www.jisuanke.ds;import java.util.ArrayList;import java.util.Scanner;/** * @author wangchong * @date 2019/5/3 18:32 * @email 876459397@qq.com * @CSDN https://blog.csdn.net/wfcn_zyq * @describe */public class Code_10_Say7 &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); int n = input.nextInt(); int m = input.nextInt(); int t = input.nextInt(); for (int i = 0; i &lt; n; i++) &#123; arrayList.add(input.next()); &#125; int index = t - 1; int num7 = 0; int i = m - 1; for (; i &lt; n; i++) &#123; while (arrayList.get(i).equals(&quot;wangchong&quot;)) &#123; i++; if (i == n) &#123; i = 0; &#125; &#125; index++; if (index % 7 == 0 || String.valueOf(index).contains(&quot;7&quot;)) &#123; arrayList.set(i,&quot;wangchong&quot;); num7++; if (num7 == n - 1) &#123; break; &#125; &#125; if (i == n - 1) &#123; i = -1; &#125; &#125; for (String str : arrayList ) &#123; if (!str.equals(&quot;wangchong&quot;)) &#123; System.out.println(str); &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","permalink":"http://yoursite.com/tags/CSDN迁移/"}]},{"title":"计蒜客  队列  小朋友报数","slug":"计蒜客  队列  小朋友报数","date":"2019-05-03T10:27:06.000Z","updated":"2019-05-14T06:56:57.973Z","comments":true,"path":"2019/05/03/计蒜客  队列  小朋友报数/","link":"","permalink":"http://yoursite.com/2019/05/03/计蒜客  队列  小朋友报数/","excerpt":"","text":"版权声明：wangchong https://blog.csdn.net/wfcn_zyq/article/details/89790073 1时间限制：1000ms 空间限制：131072K 有 n 个小朋友做游戏，他们的编号分别是 1,2,3…n1,2,3…n。他们按照编号从小到大依次顺时针围成一个圆圈，从第一个小朋友开始从 1 报数，依次按照顺时针方向报数 (加一)，报 mm 的人会离开队伍，然后下一个小朋友会继续从 1 开始报数，直到只剩一个小朋友为止。 输入格式 第一行输入两个整数，nn，mm。（1 \\leq n,m \\leq 10001≤n,m≤1000） 输出格式 输出最后一个小朋友的编号，占一行。 样例输入 110 5 样例输出 13 实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package www.jisuanke.ds;import java.util.ArrayList;import java.util.LinkedList;import java.util.Queue;import java.util.Scanner;/** * @author wangchong * @date 2019/5/3 17:11 * @email 876459397@qq.com * @CSDN https://blog.csdn.net/wfcn_zyq * @describe */public class Code_09_QueueKid &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int n = input.nextInt(); int m = input.nextInt(); ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; arrayList.add(i + 1); &#125; int index = 0; int zeroNum = 0; for (int i = 0; i &lt; n; i++) &#123; while (arrayList.get(i) == 0) &#123; i++; if (i == n) &#123; i = 0; &#125; &#125; index++; if (index % m == 0) &#123; arrayList.set(i,0); zeroNum++; index = 0; if (zeroNum == n - 1) &#123; break; &#125; &#125; if (i == n - 1) &#123; i = -1; &#125; &#125; for (int i : arrayList ) &#123; if (i != 0) &#123; System.out.println(i); &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","permalink":"http://yoursite.com/tags/CSDN迁移/"}]},{"title":"计蒜客 栈 网页跳转","slug":"计蒜客 栈 网页跳转","date":"2019-05-03T09:00:34.000Z","updated":"2019-05-14T06:57:06.181Z","comments":true,"path":"2019/05/03/计蒜客 栈 网页跳转/","link":"","permalink":"http://yoursite.com/2019/05/03/计蒜客 栈 网页跳转/","excerpt":"","text":"版权声明：wangchong https://blog.csdn.net/wfcn_zyq/article/details/89789223 1时间限制1000ms 空间限制131072K 蒜头君每天都在用一款名为 “蒜厂浏览器” 的软件。在这个浏览器中，一共三种操作：打开页面、回退和前进。它们的功能如下： 打开页面：在地址栏中输入网址，并跳转到网址对应的页面； 回退：返回到上一次访问的页面； 前进：返回到上次回退前的页面，如果上一次操作是打开页面，那么将无法前进。 现在，蒜头君打开浏览器，进行了一系列操作，你需要输出他每次操作后所在页面的网址。 输入格式 第一行输入一个整数 n(0 &lt; n \\le 100000)n(0&lt;n≤100000)，表示蒜头君的操作次数。 接下来一共 nn 行，每行首先输入一个字符串，如果是 VISIT，后面接着输入一个不含有空格和换行的网址（网址长度小于 100100），表示蒜头君在浏览器地址栏中输入的网址；如果是 BACK，表示蒜头君点击了回退按钮；如果是 FORWARD，表示蒜头君点击了前进按钮。 输出格式 对于每次操作，如果蒜头君能操作成功，输出蒜头君操作之后的网址，否则输出 Ignore。假设蒜头君输入的所有网址都是合法的。 样例输入 123456789101110VISIT https://www.jisuanke.com/course/476VISIT https://www.taobao.com/BACKBACKFORWARDFORWARDBACKVISIT https://www.jisuanke.com/course/429FORWARDBACK 样例输出 12345678910https://www.jisuanke.com/course/476https://www.taobao.com/https://www.jisuanke.com/course/476Ignorehttps://www.taobao.com/Ignorehttps://www.jisuanke.com/course/476https://www.jisuanke.com/course/429Ignorehttps://www.jisuanke.com/course/476 实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package www.jisuanke.ds;import java.util.ArrayList;import java.util.Scanner;import java.util.Stack;/** * @author wangchong * @date 2019/5/3 16:23 * @email 876459397@qq.com * @CSDN https://blog.csdn.net/wfcn_zyq * @describe */public class Code_08_WebStack &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int n = input.nextInt(); Stack&lt;String&gt; stack = new Stack&lt;&gt;(); Stack&lt;String&gt; back = new Stack&lt;&gt;(); ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; String str = input.next(); if (str.equals(&quot;VISIT&quot;)) &#123; String url = input.next(); stack.push(url); arrayList.add(url); back.removeAllElements(); &#125; else if (str.equals(&quot;BACK&quot;)) &#123; if (stack.size() &lt;= 1) &#123; arrayList.add(&quot;Ignore&quot;); &#125; else &#123; back.push(stack.pop()); arrayList.add(stack.peek()); &#125; &#125; else if (str.equals(&quot;FORWARD&quot;)) &#123; if (back.isEmpty()) &#123; arrayList.add(&quot;Ignore&quot;); &#125; else &#123; String backUrl = back.pop(); stack.push(backUrl); arrayList.add(backUrl); &#125; &#125; &#125; for (String s : arrayList ) &#123; System.out.println(s); &#125; &#125;&#125;","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","permalink":"http://yoursite.com/tags/CSDN迁移/"}]},{"title":"计蒜客 栈 左右括号匹配并输出对应位置","slug":"计蒜客 栈 左右括号匹配并输出对应位置","date":"2019-05-03T08:20:52.000Z","updated":"2019-05-14T06:57:02.501Z","comments":true,"path":"2019/05/03/计蒜客 栈 左右括号匹配并输出对应位置/","link":"","permalink":"http://yoursite.com/2019/05/03/计蒜客 栈 左右括号匹配并输出对应位置/","excerpt":"","text":"版权声明：wangchong https://blog.csdn.net/wfcn_zyq/article/details/89788711 1时间限制1000ms 空间限制131072K 蒜头君在纸上写了一个串，只包含’(’ 和’)’。一个’(’ 能唯一匹配一个’)’，但是一个匹配的’(’ 必须出现在’)’ 之前。请判断蒜头君写的字符串能否括号完全匹配，如果能，输出配对的括号的位置（匹配的括号不可以交叉，只能嵌套）。 输入格式 一行输入一个字符串只含有’(’ 和’)’，输入的字符串长度不大于 5000050000。 输出格式 如果输入括号不能匹配，输出一行 “No”，否则输出一行 “Yes”，接下来若干行每行输出 22 个整数，用空格隔开，表示所有匹配对的括号的位置（下标从 11 开始）。你可以按照任意顺序输出。 本题答案不唯一，符合要求的答案均正确 样例输入 1 (()) 样例输出 1 123Yes1 42 3 样例输入 2 1()() 样例输出 2 123Yes1 23 4 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445package www.jisuanke.ds;import java.util.HashMap;import java.util.Scanner;import java.util.Stack;/** * @author wangchong * @date 2019/5/3 15:53 * @email 876459397@qq.com * @CSDN https://blog.csdn.net/wfcn_zyq * @describe */public class Code_07_KouHao &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); String str = input.nextLine(); Stack&lt;Character&gt; stackLeft = new Stack&lt;&gt;(); Stack&lt;Integer&gt; stackIndex = new Stack&lt;&gt;(); HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); int i = 0; for (i = 0; i &lt; str.length(); i++) &#123; if (str.charAt(i) == &apos;)&apos;) &#123; if (!stackLeft.isEmpty()) &#123; stackLeft.pop(); map.put(stackIndex.pop(),i + 1); &#125; else &#123; break; &#125; &#125; else &#123; stackLeft.push(str.charAt(i)); stackIndex.push(i + 1); &#125; &#125; if (stackLeft.isEmpty() &amp;&amp; i == str.length() ) &#123; System.out.println(&quot;Yes&quot;); for (HashMap.Entry entry : map.entrySet() ) &#123; System.out.println(entry.getKey() + &quot; &quot; + entry.getValue()); &#125; &#125; else &#123; System.out.println(&quot;No&quot;); &#125; &#125;&#125;","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","permalink":"http://yoursite.com/tags/CSDN迁移/"}]},{"title":"计蒜客 集合之TreeMap 水果店","slug":"计蒜客 集合之TreeMap 水果店","date":"2019-05-03T07:30:16.000Z","updated":"2019-05-14T06:57:25.581Z","comments":true,"path":"2019/05/03/计蒜客 集合之TreeMap 水果店/","link":"","permalink":"http://yoursite.com/2019/05/03/计蒜客 集合之TreeMap 水果店/","excerpt":"","text":"版权声明：wangchong https://blog.csdn.net/wfcn_zyq/article/details/89788070 1时间限制1000ms 空间限制131072K 蒜头君经营着一个不大的水果店。他认为生存之道就是经营最受顾客欢迎的水果。现在他想要一份水果销售情况的明细表，这样就可以很容易掌握所有水果的销售情况了。蒜头君告诉你每一笔销售记录的水果名称，产地和销售的数量，请你帮他生成明细表。 输入格式 第一行是一个整数 N(0 &lt; N \\le 1000)N(0&lt;N≤1000)，表示工有 NN 次成功的交易。其后有 NN 行数据，每行表示一次交易，由水果名称 (小写字母组成，长度不超过 100100)，水果产地 (小写字母组成，长度不超过 100100) 和交易的水果数目 (正整数，不超过 10001000) 组成. 输出格式 请你输出一份排版格式正确 (请分析样本输出) 的水果销售情况明细表。这份明细表包括所有水果的产地、名称和销售数目的信息。水果先按产地分类，产地按字母顺序排列；同一产地的水果按照名称排序，名称按字母顺序排序。 样例输入 1234565apple shandong 3pineapple guangdong 1sugarcane guangdong 1pineapple guangdong 3pineapple guangdong 1 样例输出 12345guangdong |----pineapple(5) |----sugarcane(1)shandong |----apple(3) 实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package www.jisuanke.ds;import java.util.Map;import java.util.Scanner;import java.util.TreeMap;/** * @author wangchong * @date 2019/5/3 13:38 * @email 876459397@qq.com * @CSDN https://blog.csdn.net/wfcn_zyq * @describe */public class Code_06_FruitTable &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int n = input.nextInt(); Map&lt;String,Map&lt;String,Integer&gt;&gt; cityFruit = new TreeMap&lt;&gt;(); Map&lt;String,Integer&gt; fruitNum = new TreeMap&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; String fruit = input.next(); String city = input.next(); int num = input.nextInt(); if (cityFruit.containsKey(city)) &#123; fruitNum = new TreeMap&lt;&gt;(); fruitNum.putAll(cityFruit.get(city)); &#125; else &#123; fruitNum = new TreeMap&lt;&gt;(); &#125; if (fruitNum.containsKey(fruit)) &#123; fruitNum.put(fruit,fruitNum.get(fruit) + num); &#125; else &#123; fruitNum.put(fruit,num); &#125; cityFruit.put(city,fruitNum); &#125; for (Map.Entry&lt;String,Map&lt;String,Integer&gt;&gt; entry : cityFruit.entrySet() ) &#123; System.out.println(entry.getKey()); for (Map.Entry&lt;String,Integer&gt; fruitMap : cityFruit.get(entry.getKey()).entrySet() ) &#123; System.out.println(&quot; |----&quot; + fruitMap.getKey() + &quot;(&quot; + fruitMap.getValue() + &quot;)&quot;); &#125; &#125; &#125;&#125; 小tips 每次换了城市的时候必须刷新fruitNum，每次遇到相同的城市必须刷新fruitNum并且将之前对应的表拿出来再赋给他才能保证不同城市不会串到一起，我在找个地方吃力很大的亏 entend 学了TreeMap的基础知识，我想如果TreeMap可以放基本数据类型和String类型，那么应该可以放集合，没想到真的可以，根据这一题，就尝试了一下，题目要求中有三个值，所以普通的key，value是不可能满足的，那么如果value又是一个Map那么就可以满足三个值的对应关系，一个城市对应一批水果，水果则用TreeMap存放，就可以达到输出对应每个城市的水果销售情况了。 我只对解法做了简单的介绍，要想明白其中的道理，必须体会我的代码中的魅力。鬼知道debug用来多长时间。","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","permalink":"http://yoursite.com/tags/CSDN迁移/"}]},{"title":"Study：HashMap的迭代（HashMap遍历）","slug":"Study：HashMap的迭代（HashMap遍历）","date":"2019-05-03T03:11:44.000Z","updated":"2019-05-14T06:56:16.715Z","comments":true,"path":"2019/05/03/Study：HashMap的迭代（HashMap遍历）/","link":"","permalink":"http://yoursite.com/2019/05/03/Study：HashMap的迭代（HashMap遍历）/","excerpt":"","text":"版权声明：wangchong https://blog.csdn.net/wfcn_zyq/article/details/89785870 通过entuySet()结合迭代器遍历HashMap映射表 123456789101112import java.util.HashMap;public class HashMapTest &#123; public static void main(String[] args) &#123; HashMap&lt;String, Integer&gt; dict = new HashMap&lt;String, Integer&gt;(); // &#123;&#125; dict.put(&quot;王崇&quot;, 1); dict.put(&quot;西安科技大学&quot;, 2); dict.put(&quot;软件工程&quot;, 1); for (HashMap.Entry&lt;String, Integer&gt; entry : dict.entrySet()) &#123; System.out.println(entry.getKey() + &quot; is in class &quot; + entry.getValue()); &#125; &#125;&#125;","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","permalink":"http://yoursite.com/tags/CSDN迁移/"}]},{"title":"计蒜客 集合 蒜头学英语","slug":"计蒜客 集合 蒜头学英语","date":"2019-05-03T02:56:27.000Z","updated":"2019-05-14T06:57:17.474Z","comments":true,"path":"2019/05/03/计蒜客 集合 蒜头学英语/","link":"","permalink":"http://yoursite.com/2019/05/03/计蒜客 集合 蒜头学英语/","excerpt":"","text":"版权声明：wangchong https://blog.csdn.net/wfcn_zyq/article/details/89785694 1时间限制1000ms 空间限制131072K 蒜头君快要考托福了，这几天，蒜头君每天早上都起来记英语单词。花椰妹时不时地来考一考蒜头君：花椰妹会询问蒜头君一个单词，如果蒜头君背过这个单词，蒜头君会告诉花椰妹这个单词的意思，不然蒜头君会跟花椰妹说还没有背过。单词是由连续的大写或者小写字母组成。注意单词中字母大小写是等价的。比如 You 和 you 是一个单词。 输入格式 首先输入一个 n(1 \\le n \\le 100000)n(1≤n≤100000) 表示事件数。接下来 nn 行，每行表示一个事件。每个事件输入为一个整数 dd 和一个单词 wordword（单词长度不大于 2020），用空格隔开。如果 d=0d=0，表示蒜头君记住了 wordword 这个单词，如果 d=1d=1，表示这是一个 测试，测试蒜头君是否认识单词 wordword（花椰妹永远不会告诉蒜头君这个单词的意思）。事件的输入是按照时间先后顺序输入的。 输出格式 对于花椰妹的每次 测试，如果蒜头君认识这个单词，输出一行 Yes, 否则输出一行 No。 样例输入 1 12345650 we0 are1 family0 Family1 Family 样例输出 1 12NoYes 样例输入 2 1234541 jisuanke0 Jisuanke0 JISUANKE1 JiSuanKe 样例输出 2 12NoYes 123456789101112131415161718192021222324252627282930313233343536373839404142package www.jisuanke.ds;import java.util.ArrayList;import java.util.Scanner;/** * @author wangchong * @date 2019/5/3 10:14 * @email 876459397@qq.com * @CSDN https://blog.csdn.net/wfcn_zyq * @describe */public class Code_04_Vocabulary &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int n = input.nextInt(); ArrayList&lt;String&gt; vocabulary = new ArrayList&lt;&gt;(); ArrayList&lt;String&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; int first = input.nextInt(); String vo = input.next().toLowerCase(); if (first == 0) &#123; if (vocabulary.contains(vo)) &#123; continue; &#125; vocabulary.add(vo); &#125; else &#123; if (vocabulary.contains(vo)) &#123; res.add(&quot;Yes&quot;); &#125; else &#123; res.add(&quot;No&quot;); &#125; &#125; &#125; for (String s : res ) &#123; System.out.println(s); &#125; &#125;&#125; 弄巧成拙 使用toLowerCase()使得所有的单词均为小写，在字符串的比较的时候，就更加容易比较，事实上，只需使用集合的contains函数就可知道是否记过，但是正是因为这样在最后一个测试样例中时间约为3000ms，估计是因为使用转小写函数，测试用例过多花费时间过长","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","permalink":"http://yoursite.com/tags/CSDN迁移/"}]},{"title":"Study：忽略大小写比较字符串","slug":"Study：忽略大小写比较字符串","date":"2019-05-03T02:19:56.000Z","updated":"2019-05-14T06:56:20.524Z","comments":true,"path":"2019/05/03/Study：忽略大小写比较字符串/","link":"","permalink":"http://yoursite.com/2019/05/03/Study：忽略大小写比较字符串/","excerpt":"","text":"版权声明：wangchong https://blog.csdn.net/wfcn_zyq/article/details/89785334 有时候我们需要忽略大小写比较两个字符串是否相等 使用String类中的函数 样例 12345678910111213141516package www.wangchong.study;/** * @author wangchong * @date 2019/5/3 10:15 * @email 876459397@qq.com * @CSDN https://blog.csdn.net/wfcn_zyq * @describe */public class IgnoreUpperLowerCase &#123; public static void main(String[] args) &#123; String a = &quot;ABC&quot;; String b = &quot;abc&quot;; System.out.println(a.equalsIgnoreCase(b)); &#125;&#125; 输出","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","permalink":"http://yoursite.com/tags/CSDN迁移/"}]},{"title":"计蒜客 集合 计算集合的并","slug":"计蒜客 集合 计算集合的并","date":"2019-05-03T02:09:11.000Z","updated":"2019-05-14T06:57:21.187Z","comments":true,"path":"2019/05/03/计蒜客 集合 计算集合的并/","link":"","permalink":"http://yoursite.com/2019/05/03/计蒜客 集合 计算集合的并/","excerpt":"","text":"版权声明：wangchong https://blog.csdn.net/wfcn_zyq/article/details/89785241 1时间限制1000ms 空间限制131072K 给你两个集合，计算其并集，即 {A} + {B}{A}+{B}。 注：{A} + {B}{A}+{B} 中不允许出现重复元素，但是 {A}{A} 与 {B}{B} 之间可能存在相同元素。 输入格式 输入数据分为三行，第一行有两个数字 n, m(0&lt;n,m\\leq 10000)n,m(0&lt;n,m≤10000)，分别表示集合 A 和集合 B 的元素个数。后两行分别表示集合 A 和集合 B。每个元素为不超出 int 范围的整数，每个元素之间用一个空格隔开。 输出格式 输出一行数据，表示合并后的集合，要求从小到大输出，每个元素之间用一个空格隔开。 样例输入 1 1 2 1 2 3 样例输出 1 1 2 3 样例输入 2 1 2 1 1 2 样例输出 2 1 2 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.ArrayList;import java.util.Collections;import java.util.HashSet;import java.util.Scanner;/** * @author wangchong * @date 2019/5/3 9:49 * @email 876459397@qq.com * @CSDN https://blog.csdn.net/wfcn_zyq * @describe */public class Main &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int n = input.nextInt(); int m = input.nextInt(); ArrayList&lt;Integer&gt; A = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; B = new ArrayList&lt;&gt;(); HashSet&lt;Integer&gt; res = new HashSet(); for (int i = 0; i &lt; n; i++) &#123; A.add(input.nextInt()); &#125; for (int i = 0; i &lt; m; i++) &#123; B.add(input.nextInt()); &#125; res.addAll(A); res.addAll(B); ArrayList&lt;Integer&gt; resArrayList = new ArrayList&lt;&gt;(); resArrayList.addAll(res); Collections.sort(resArrayList); for (int i = 0; i &lt; resArrayList.size(); i++) &#123; if (i &lt; resArrayList.size() - 1) &#123; System.out.print(resArrayList.get(i) + &quot; &quot;); &#125; else &#123; System.out.print(resArrayList.get(i)); &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","permalink":"http://yoursite.com/tags/CSDN迁移/"}]},{"title":"计蒜客 集合 打印锯齿矩阵","slug":"计蒜客 集合 打印锯齿矩阵","date":"2019-05-03T01:26:13.000Z","updated":"2019-05-14T06:57:13.839Z","comments":true,"path":"2019/05/03/计蒜客 集合 打印锯齿矩阵/","link":"","permalink":"http://yoursite.com/2019/05/03/计蒜客 集合 打印锯齿矩阵/","excerpt":"","text":"版权声明：wangchong https://blog.csdn.net/wfcn_zyq/article/details/89784878 1时间限制1000ms 空间限制131072K 锯齿矩阵是指每一行包含的元素个数不相同的矩阵，比如： 12345613 5 2 6 122 3 431 6 2 7 读入若干对整数 (x,y)(x,y)，表示在第 xx 行的末尾加上一个元素 yy。输出最终的锯齿数组。初始时矩阵为空。 输入格式 第一行输入两个整数 n,m(1 \\leq n,m \\leq 10000)n,m(1≤n,m≤10000)，其中 nn 表示锯齿数组的行数，mm 表示插入的元素总数。 接下来一共 mm 行，每行两个整数 x,y(1 \\leq x \\leq n, 0 \\leq y \\leq 10000)x,y(1≤x≤n,0≤y≤10000)，表示在第 xx 行的末尾插入一个元素 yy。 输出格式 一共输出 nn 行，每行若干个用空格分隔的整数。如果某行没有任何元素，则输出一个空行。 样例输入 123456789101112133 121 32 22 32 43 13 61 51 21 63 23 71 1 样例输出 1233 5 2 6 12 3 41 6 2 7 123456789101112131415161718192021222324252627282930313233343536373839package www.jisuanke.ds;import java.util.ArrayList;import java.util.Scanner;/** * @author wangchong * @date 2019/4/30 16:09 * @email 876459397@qq.com * @CSDN https://blog.csdn.net/wfcn_zyq * @describe */public class Code_01_SpecialMatrix &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int n = input.nextInt(); int m = input.nextInt(); ArrayList[] arrayList = new ArrayList[n]; for (int i = 0; i &lt; n; i++) &#123; arrayList[i] = new ArrayList&lt;Integer&gt;(); &#125; for (int i = 0; i &lt; m; i++) &#123; int x = input.nextInt(); int y = input.nextInt(); arrayList[x - 1].add(y); &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; arrayList[i].size(); j++) &#123; if (j &lt; arrayList[i].size() - 1) &#123; System.out.print(arrayList[i].get(j) + &quot; &quot;); &#125; else &#123; System.out.print(arrayList[i].get(j)); &#125; &#125; System.out.println(); &#125; &#125;&#125;","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","permalink":"http://yoursite.com/tags/CSDN迁移/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-04-30T17:00:38.160Z","updated":"2019-05-14T07:07:03.709Z","comments":true,"path":"2019/05/01/hello-world/","link":"","permalink":"http://yoursite.com/2019/05/01/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"RPG角色生成器","slug":"RPG角色生成器","date":"2019-04-30T11:59:00.000Z","updated":"2019-05-14T06:56:12.911Z","comments":true,"path":"2019/04/30/RPG角色生成器/","link":"","permalink":"http://yoursite.com/2019/04/30/RPG角色生成器/","excerpt":"","text":"版权声明：wangchong https://blog.csdn.net/wfcn_zyq/article/details/89390244 需求 1.功能描述 几乎所有的RPG游戏（一种源自《龙与地下城》的游戏类型）在进入游戏时都会让用户自己来创建自己喜欢的角色。本次上机要求编写一个简化的创建游戏角色的程序。 2.游戏角色应有的属性 本题目要求的游戏角色应有以下属性：名字、性别、种族、职业、力量、敏捷、体力、智力、智慧、生命值和魔法值。 名字：不超过50个字符。 性别：可以选择男性和女性。 种族：一共可选五个种族，人类、精灵、兽人、矮人和元素。 职业：可选六种职业，狂战士、圣骑士、刺客、猎手、祭司和巫师。 其余属性均为整数。 本题目要求首先用户输入角色姓名，然后由用户选择角色性别，然后由用户选择种族，然后选择职业，然后自动分配力量、敏捷、体力、智力和智慧属性，并计算生命值和魔法值。 生命值=体力20。 魔法值=（智力+智慧）10。 3.职业限制 很多职业会限制某些种族选择，例如兽人不能就职圣骑士等等，种族和职业的限制表如下： 所以在要求用户选择职业时，输出信息里面只能有用户所选择种族可以就职的职业。 4.初始属性 本题目要求力量、敏捷、体力、智力和智慧要求是随机值（利用随机数函数来取得随机数），但是五项属性的总和应该是100，并且应该和职业相关。例如狂战士的体力和力量就要比较高，而巫师需要较高的智力，而祭司则需要较高的智慧。各职业初始属性的大致比例应遵从下表： 例如，前面示意图中的祭司的初始属性，大致满足该比例，但是应该是随机的。 然后利用属性值计算生命值和魔法值。 5.显示信息 最后向用户显示该角色的所有信息，然后询问用户是否满意，如用户不满意则重新创建，若用户满意则程序结束，并将用户创建角色的相关信息写入文件保存。 一、题目分析 用户自己来创建自己喜欢的角色。本次上机要求编写一个简化的创建游戏角色的程序。 RPG游戏角色初始化，很容易想到设计一个角色类Character，这个类的属性信息即为角色的的属性，设置每一个属性的getter和setter方法，对属性进行值的设置和获取 设置一个主类RPG来对角色属性进行具体的设置，要求符合题目的要求设置满足不同种族之间有职业选择限制，各个职业的属性比例应符合对应角色的真实比例，这些属性随机生成，但大致满足比例，所以只需要在比例附近设置一个范围，生成的随机基本上都满足就比例。但是，在生成属性值的时候，要求总和要保证为100，那么只需要在生成最后一个属性值的时候，用100减去前面生成的值即可，但是，这有不能保证最后一个一定为一个正数，因为前面生成的数都有可能都偏向比比例大的方向生成随机数，所以就需要不断的进行这一步生成随机数的过程，一定会有生成满足最后一个不为负数的时候，这不会等很长时间因为过程完全随机很容易就得到偏向比例下方和偏向上方大致中和。 最后向用户显示该角色的所有信息，然后询问用户是否满意，如用户不满意则重新创建，若用户满意则程序结束，并将用户创建角色的相关信息写入文件保存。 二、类图设计 三、程序实现 程序主要实现 123456789101112131415161718192021222324252627282930313233343536/** * 对用户的输入做检查,确保只有输入0或1才能进行下一步 * @return 整型0或1 */private static int get01()/** * 对用户的输入做检查,确保只有输入0至2才能进行下一步 * @return 整型0至2 */private static int get02()/** * 设置其他的属性包括力量、敏捷、体力、智力 * @param op 职业 * @return 一个含有4个数的数组分别表示力量、敏捷、体力、智力 */private static int[] setOther(String op)/** * 设置种族 * @param select 选择的选项 * @return 对应的选项的的种族 */private static String setRace(int select)/** * 设置职业 * @param op 种族 * @return 对应种族的下属的选择的职业 */private static String setOccupation(String op)/** * 设置其他的属性包括力量、敏捷、体力、智力 * @param op 职业 * @return 一个含有4个数的数组分别表示力量、敏捷、体力、智力 */private static int[] setOther(String op) 完整实现 Character类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package www.homework.EmbarkationFour;public class Character &#123; private String name;//名字 private String sex;//性别 private String race;//种族 private String occupation;//职业 private int power;//力量 private int agility;//敏捷 private int physical;//体力 private int brains;//智力 private int wit;//智慧 private int life;//生命值 private int magic;//魔法值 public String getOccupation() &#123; return occupation; &#125; public void setOccupation(String occupation) &#123; this.occupation = occupation; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getRace() &#123; return race; &#125; public void setRace(String race) &#123; this.race = race; &#125; public int getPower() &#123; return power; &#125; public void setPower(int power) &#123; this.power = power; &#125; public int getAgility() &#123; return agility; &#125; public void setAgility(int agility) &#123; this.agility = agility; &#125; public int getPhysical() &#123; return physical; &#125; public void setPhysical(int physical) &#123; this.physical = physical; &#125; public int getBrains() &#123; return brains; &#125; public void setBrains(int brains) &#123; this.brains = brains; &#125; public int getWit() &#123; return wit; &#125; public void setWit(int wit) &#123; this.wit = wit; &#125; public int getLife() &#123; return life; &#125; public void setLife(int life) &#123; this.life = life; &#125; public int getMagic() &#123; return magic; &#125; public void setMagic(int magic) &#123; this.magic = magic; &#125;&#125; RPG类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318package www.homework.EmbarkationFour;import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.io.Writer;import java.util.Scanner;public class RPG &#123; /** * 对用户的输入做检查,确保只有输入0或1才能进行下一步 * @return 整型0或1 */ private static int get01() &#123; Scanner input = new Scanner(System.in); while (true) &#123; String re = input.nextLine(); if (re.equals(&quot;0&quot;) || re.equals(&quot;1&quot;)) &#123; return Integer.valueOf(re); &#125; else &#123; System.out.println(&quot;没有该选项,重新输入吧！&quot;); &#125; &#125; &#125; /** * 对用户的输入做检查,确保只有输入0至2才能进行下一步 * @return 整型0至2 */ private static int get02() &#123; Scanner input = new Scanner(System.in); while (true) &#123; String re = input.nextLine(); if (re.equals(&quot;0&quot;) || re.equals(&quot;1&quot;) || re.equals(&quot;2&quot;) ) &#123; return Integer.valueOf(re); &#125; else &#123; System.out.println(&quot;没有该选项,重新输入吧！&quot;); &#125; &#125; &#125; private static int get03() &#123; Scanner input = new Scanner(System.in); while (true) &#123; String re = input.nextLine(); if (re.equals(&quot;0&quot;) || re.equals(&quot;1&quot;) || re.equals(&quot;2&quot;) || re.equals(&quot;3&quot;) ) &#123; return Integer.valueOf(re); &#125; else &#123; System.out.println(&quot;没有该选项,重新输入吧！&quot;); &#125; &#125; &#125; private static int get04() &#123; Scanner input = new Scanner(System.in); while (true) &#123; String re = input.nextLine(); if (re.equals(&quot;0&quot;) || re.equals(&quot;1&quot;) || re.equals(&quot;2&quot;) || re.equals(&quot;3&quot;) || re.equals(&quot;4&quot;)) &#123; return Integer.valueOf(re); &#125; else &#123; System.out.println(&quot;没有该选项,重新输入吧！&quot;); &#125; &#125; &#125; private static int get05() &#123; Scanner input = new Scanner(System.in); while (true) &#123; String re = input.nextLine(); if (re.equals(&quot;0&quot;) || re.equals(&quot;1&quot;) || re.equals(&quot;2&quot;) || re.equals(&quot;3&quot;) || re.equals(&quot;4&quot;) || re.equals(&quot;5&quot;)) &#123; return Integer.valueOf(re); &#125; else &#123; System.out.println(&quot;没有该选项,重新输入吧！&quot;); &#125; &#125; &#125; /** * 设置种族 * @param select 选择的选项 * @return 对应的选项的的种族 */ private static String setRace(int select) &#123; switch (select) &#123; case 0 : return &quot;人类&quot;; case 1: return &quot;精灵&quot;; case 2: return &quot;兽人&quot;; case 3: return &quot;矮人&quot;; case 4: return &quot;元素&quot;; default: return null; &#125; &#125; /** * 设置职业 * @param op 种族 * @return 对应种族的下属的选择的职业 */ private static String setOccupation(String op) &#123; int select; switch (op) &#123; case &quot;人类&quot;: System.out.print(&quot;选择您的职业(0狂战士,1圣骑士,2刺客,3猎手,4祭司,5巫师):&quot;); select = get05(); if (select == 0) &#123; return &quot;狂战士&quot;; &#125; else if (select == 1) &#123; return &quot;圣骑士&quot;; &#125; else if (select == 2) &#123; return &quot;刺客&quot;; &#125; else if (select == 3) &#123; return &quot;猎手&quot;; &#125; else if (select == 4) &#123; return &quot;祭司&quot;; &#125; else if (select == 5) &#123; return &quot;巫师&quot;; &#125; break; case &quot;精灵&quot;: System.out.print(&quot;选择您的职业(0刺客,1猎手,2祭司,3巫师):&quot;); select = get03(); if (select == 0) &#123; return &quot;刺客&quot;; &#125; else if (select == 1) &#123; return &quot;猎手&quot;; &#125; else if (select == 2) &#123; return &quot;祭司&quot;; &#125; else if (select == 3) &#123; return &quot;巫师&quot;; &#125; break; case &quot;兽人&quot;: System.out.print(&quot;选择您的职业(0狂战士,1猎手,2祭司):&quot;); select = get02(); if (select == 0) &#123; return &quot;狂战士&quot;; &#125; else if (select == 1) &#123; return &quot;猎手&quot;; &#125; else if (select == 2) &#123; return &quot;祭司&quot;; &#125; break; case &quot;矮人&quot;: System.out.print(&quot;选择您的职业(0狂战士,1圣骑士,2祭司):&quot;); select = get02(); if (select == 0) &#123; return &quot;狂战士&quot;; &#125; else if (select == 1) &#123; return &quot;圣骑士&quot;; &#125; else if (select == 2) &#123; return &quot;祭司&quot;; &#125; break; case &quot;元素&quot;: System.out.print(&quot;选择您的职业(0祭司,1巫师):&quot;); select = get01(); if (select == 0) &#123; return &quot;祭司&quot;; &#125; else if (select == 1) &#123; return &quot;巫师&quot;; &#125; break; default: return null; &#125; return null; &#125; /** * 设置其他的属性包括力量、敏捷、体力、智力 * @param op 职业 * @return 一个含有4个数的数组分别表示力量、敏捷、体力、智力 */ private static int[] setOther(String op) &#123; int[] arr = new int[5]; while (true) &#123; switch (op) &#123; case &quot;狂战士&quot;: arr[0] = (int) (Math.random() * 11) + 35; arr[1] = (int) (Math.random() * 11) + 15; arr[2] = (int) (Math.random() * 11) + 25; arr[3] = (int) (Math.random() * 11); arr[4] = 100 - arr[0] - arr[1] - arr[2] - arr[3]; break; case &quot;圣骑士&quot;: arr[0] = (int) (Math.random() * 11) + 20; arr[1] = (int) (Math.random() * 11) + 10; arr[2] = (int) (Math.random() * 11) + 25; arr[3] = (int) (Math.random() * 11) + 15; arr[4] = 100 - arr[0] - arr[1] - arr[2] - arr[3]; break; case &quot;刺客&quot;: arr[0] = (int) (Math.random() * 11) + 15; arr[1] = (int) (Math.random() * 11) + 30; arr[2] = (int) (Math.random() * 11) + 15; arr[3] = (int) (Math.random() * 11) + 10; arr[4] = 100 - arr[0] - arr[1] - arr[2] - arr[3]; break; case &quot;猎手&quot;: arr[0] = (int) (Math.random() * 11) + 10; arr[1] = (int) (Math.random() * 11) + 35; arr[2] = (int) (Math.random() * 11) + 5; arr[3] = (int) (Math.random() * 11) + 30; arr[4] = 100 - arr[0] - arr[1] - arr[2] - arr[3]; break; case &quot;祭司&quot;: arr[0] = (int) (Math.random() * 11) + 10; arr[1] = (int) (Math.random() * 11) + 15; arr[2] = (int) (Math.random() * 11) + 10; arr[3] = (int) (Math.random() * 11) + 30; arr[4] = 100 - arr[0] - arr[1] - arr[2] - arr[3]; break; case &quot;巫师&quot;: arr[0] = (int) (Math.random() * 11) + 5; arr[1] = (int) (Math.random() * 11) + 15; arr[2] = (int) (Math.random() * 11) + 5; arr[3] = (int) (Math.random() * 11) + 15; arr[4] = 100 - arr[0] - arr[1] - arr[2] - arr[3]; break; &#125; if (arr[4] &gt; 0) &#123; break; &#125; &#125; return arr; &#125; /** * 显示 character各个属性信息 * @param character character对象(RPG角色) */ private static void show(Character character) &#123; System.out.println(&quot;=========================&quot;); System.out.println(&quot;姓名&quot; + &quot; &quot; + character.getName()); System.out.println(&quot;=========================&quot;); System.out.println(&quot;性别&quot; + &quot; &quot; + character.getSex()); System.out.println(&quot;=========================&quot;); System.out.println(&quot;种族&quot; + &quot; &quot; + character.getRace()); System.out.println(&quot;=========================&quot;); System.out.println(&quot;职业&quot; + &quot; &quot; + character.getOccupation()); System.out.println(&quot;=========================&quot;); System.out.println(&quot;力量&quot; + &quot; &quot; + character.getPower()); System.out.println(&quot;=========================&quot;); System.out.println(&quot;敏捷&quot; + &quot; &quot; + character.getAgility()); System.out.println(&quot;=========================&quot;); System.out.println(&quot;体力&quot; + &quot; &quot; + character.getPhysical()); System.out.println(&quot;=========================&quot;); System.out.println(&quot;智力&quot; + &quot; &quot; + character.getBrains()); System.out.println(&quot;=========================&quot;); System.out.println(&quot;智慧&quot; + &quot; &quot; + character.getWit()); System.out.println(&quot;=========================&quot;); System.out.println(&quot;生命值&quot; + &quot; &quot; + character.getLife()); System.out.println(&quot;=========================&quot;); System.out.println(&quot;魔法值&quot; + &quot; &quot; + character.getMagic()); &#125; public static void main(String[] args) throws IOException &#123; Scanner input = new Scanner(System.in); while (true) &#123; Character character = new Character(); while (true) &#123; System.out.print(&quot;输入您游戏角色的姓名:&quot;); String name = input.nextLine(); character.setName(name); if (name.length() &gt;= 50) &#123; System.out.println(&quot;名字不能超过50个字符！重新输入吧！&quot;); &#125; else &#123; break; &#125; &#125; System.out.print(&quot;选择您游戏角色的姓别(0男性,1女性):&quot;); int select = get01(); if (select == 0) &#123; character.setSex(&quot;男&quot;); &#125; else &#123; character.setSex(&quot;女&quot;); &#125; System.out.print(&quot;选择您游戏角色的种族(0人类,1精灵,2兽人,3矮人,4元素):&quot;); select = get04(); character.setRace(setRace(select)); character.setOccupation(setOccupation(character.getRace())); int[] arr = setOther(character.getOccupation()); character.setPower(arr[0]); character.setAgility(arr[1]); character.setPhysical(arr[2]); character.setBrains(arr[3]); character.setWit(arr[4]); character.setLife(arr[2] * 20); character.setMagic((arr[3] + arr[4]) * 10); show(character); System.out.println(&quot;你是否满意这个角色呢？你要满意我就存文件了,你要是不满意呢,那就重新创建了。&quot;); System.out.println(&quot;0.满意 1.也不行呀&quot;); select = get01(); if (select == 0) &#123; File file = new File(&quot;F:\\\\rpg.txt&quot;); Writer writer = new FileWriter(file); writer.write(&quot;姓名:&quot; + character.getName() + &quot;\\r\\n&quot;); writer.write(&quot;性别:&quot; + character.getSex() + &quot;\\r\\n&quot;); writer.write(&quot;种族:&quot; + character.getRace() + &quot;\\r\\n&quot;); writer.write(&quot;职业:&quot; + character.getOccupation() + &quot;\\r\\n&quot;); writer.write(&quot;力量:&quot; + character.getPower() + &quot;\\r\\n&quot;); writer.write(&quot;敏捷:&quot; + character.getAgility() + &quot;\\r\\n&quot;); writer.write(&quot;体力:&quot; + character.getPhysical() + &quot;\\r\\n&quot;); writer.write(&quot;智力:&quot; + character.getBrains() + &quot;\\r\\n&quot;); writer.write(&quot;智慧:&quot; + character.getWit() + &quot;\\r\\n&quot;); writer.write(&quot;生命值:&quot; + character.getLife() + &quot;\\r\\n&quot;); writer.write(&quot;生命值:&quot; + character.getMagic() + &quot;\\r\\n&quot;); writer.close(); System.out.println(&quot;既然都满意了,那就祝您生活愉快吧!&quot;); System.out.println(&quot;bay:)&quot;); break; &#125; &#125; &#125;&#125; 四、调试、测试及运行结果 4.1调试截图 123456789101112Character类下的各个属性对应的部分private String name;//名字private String sex;//性别private String race;//种族private String occupation;//职业private int power;//力量private int agility;//敏捷private int physical;//体力private int brains;//智力private int wit;//智慧private int life;//生命值private int magic;//魔法值 当输入角色名称和角色性别时 当选择完种族和职业的时候后面就会随机生成其他属性的值 4.2测试截图 输入名字超过50个字符，报错，重新输入 选择性别时，输入不正确的选项，报错，直到输入正确进行下一步 选择角色时，输入不正确的选项，报错，直到输入正确进行下一步 选择职业时，输入不正确的选项，报错，直到输入正确进行下一步 选择是人类时，只有以下5个选项，并且生成符合比例的属性值 选择是精灵时，只有以下4个选项，并且生成符合比例的属性值 选择是兽人时，只有3个职业选择，并且生成符合比例的属性值 选择是矮人时，只有3个职业选择，并且生成符合比例的属性值 选择是元素时，只有2个职业选择，并且生成符合比例的属性值 最终询问是否满意角色的生成，进行错误输入检查 满意了就将信息存入rpg.txt文件下 五、经验归纳 本次作业加强了我们对类概念的掌握，使编写程序更加面向对象化，实现Character类单独实现RPG角色属性，然后进行正常的输入输出检查，get01()，get02()，get03()，get04()，get05()，专门获得满足需求的值，对函数的设计也变的更加模块化。 再次练习了对文件类的操作。 总体来说这次练习相对简单。","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","permalink":"http://yoursite.com/tags/CSDN迁移/"}]},{"title":"Java中HashMap数组","slug":"Java中HashMap数组","date":"2019-04-30T08:37:03.000Z","updated":"2019-05-14T06:55:27.231Z","comments":true,"path":"2019/04/30/Java中HashMap数组/","link":"","permalink":"http://yoursite.com/2019/04/30/Java中HashMap数组/","excerpt":"","text":"版权声明：wangchong https://blog.csdn.net/wfcn_zyq/article/details/89712257 天梯赛 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package www.tianti;import java.util.ArrayList;import java.util.HashMap;import java.util.Scanner;public class L7_4_Shuai_Hash &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int line = input.nextInt(); HashMap[] arr = new HashMap[line]; for (int i = 0; i &lt; line; i++) &#123; arr[i] = new HashMap&lt;Integer,Integer&gt;(); &#125; for (int i = 0; i &lt; line; i++) &#123; int nLine = input.nextInt(); for (int j = 0; j &lt; nLine; j++) &#123; int cur = input.nextInt(); arr[i].put(cur,cur); &#125; &#125; int nCe = input.nextInt(); int[] chaZhao = new int[nCe]; for (int i = 0; i &lt; nCe; i++) &#123; chaZhao[i] = input.nextInt(); &#125; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; nCe; i++) &#123; int notIn = 0; for (int j = 0; j &lt; line; j++) &#123; if (arr[j].containsKey(chaZhao[i]) &amp;&amp; arr[j].size() &lt;= 1) &#123; if (!arrayList.contains(chaZhao[i]))&#123; arrayList.add(chaZhao[i]); &#125; &#125; else if (arr[j].containsKey(chaZhao[i])) &#123; continue; &#125; else &#123; notIn++; &#125; &#125; if (notIn == line) &#123; if (!arrayList.contains(chaZhao[i])) &#123; arrayList.add(chaZhao[i]); &#125; &#125; &#125; for (int i = 0; i &lt; arrayList.size(); i++) &#123; if (i == arrayList.size() - 1) &#123; System.out.print(arrayList.get(i)); &#125;else &#123; System.out.print(arrayList.get(i) + &quot; &quot;); &#125; &#125; if (arrayList.size() == 0) &#123; System.out.println(&quot;No one is handsome&quot;); &#125; &#125;&#125;","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","permalink":"http://yoursite.com/tags/CSDN迁移/"}]},{"title":"Java中使用ArrayList创建二维数组","slug":"Java中使用ArrayList创建二维数组","date":"2019-04-30T08:35:20.000Z","updated":"2019-05-14T06:55:33.375Z","comments":true,"path":"2019/04/30/Java中使用ArrayList创建二维数组/","link":"","permalink":"http://yoursite.com/2019/04/30/Java中使用ArrayList创建二维数组/","excerpt":"","text":"版权声明：wangchong https://blog.csdn.net/wfcn_zyq/article/details/89712213 计蒜客data structure：Code_01 1234567891011121314151617181920212223242526272829303132333435363738package www.jisuanke.ds;import java.util.ArrayList;import java.util.Scanner;/** * @author wangchong * @date 2019/4/30 16:09 * @email 876459397@qq.com * @CSDN https://blog.csdn.net/wfcn_zyq * @describe */public class Code_01_SpecialMatrix &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int n = input.nextInt(); int m = input.nextInt(); ArrayList[] arrayList = new ArrayList[n]; for (int i = 0; i &lt; n; i++) &#123; arrayList[i] = new ArrayList&lt;Integer&gt;(); &#125; for (int i = 0; i &lt; m; i++) &#123; int x = input.nextInt(); int y = input.nextInt(); arrayList[x - 1].add(y); &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; arrayList[i].size(); j++) &#123; if (j &lt; arrayList[i].size() - 1) &#123; System.out.print(arrayList[i].get(j) + &quot; &quot;); &#125; else &#123; System.out.print(arrayList[i].get(j)); &#125; &#125; System.out.println(); &#125; &#125;&#125;","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","permalink":"http://yoursite.com/tags/CSDN迁移/"}]},{"title":"24点游戏","slug":"24点游戏","date":"2019-04-18T14:40:50.000Z","updated":"2019-05-14T06:54:55.240Z","comments":true,"path":"2019/04/18/24点游戏/","link":"","permalink":"http://yoursite.com/2019/04/18/24点游戏/","excerpt":"","text":"版权声明：wangchong https://blog.csdn.net/wfcn_zyq/article/details/89195692 1.题目分析 12345678910111213141516171819202122232425262728293031323334353637383924点游戏是经典的纸牌益智游戏。常见游戏规则： 从扑克中每次取出4张牌。使用加减乘除，第一个能得出24者为赢。 （其中，J代表11，Q代表12，K代表13，A代表1），按照要求编程解决24点游戏。基本要求： 随机生成4个代表扑克牌牌面的数字字母，程序自动列出所有可能算出24的表达式，用擅长的语言（C/C++/Java或其他均可）实现程序解决问题。 1.程序风格良好(使用自定义注释模板) 2.列出表达式无重复。提高要求：用户初始生命值为一给定值（比如3），初始分数为0。随机生成4个代表扑克牌牌面的数字或字母，由用户输入包含这4个数字或字母的运算表达式（可包含括号），如果表达式计算结果为24则代表用户赢了此局。 1. 程序风格良好(使用自定义注释模板) 2.使用计时器要求用户在规定时间内输入表达式，如果规定时间内运算 正确则加分，超时或运算错误则进入下一题并减少生命值（不扣分）。 3.所有成绩均可记录在TopList.txt文件中。分析与解法 最直接的想法就是采用穷举法，因为运算符号只有4种，每个数字只能使 用一次，所以通过穷举4个数所有可能的表达式，并分别计算出各表达式 的值，就可以得到答案。 先不考虑使用括号，可以做出如下分析: 因为每个数只能使用一次，那么就对4个数进行全排列,总共有4!=4 * 3 * 2 * 1=24 种排列。4个数的四则运算中总共需要3个运算符，同一运算符可以重复出现， 那么对于每一个排列，总共可有4 * 4 * 4种表达式。因此在不考虑括号的情况下， 总共可以得到4! * 4= 1536种表达式。 接下来再考虑加上括号后的情况，对于4个数而言，总共会有以下5种加括号的方式: (A(B(CD))、 (A((BC)D)、 ((4B)(CD))、 (A(BC)D)、 (AB)C)D)。 所以需要遍历的表达式数最多有4! * 4 * 5 = 7680种。当然，这里可以采用逆波兰 表达式的方法，但其表达式数仍为4! * 4 * 5= 7680种。 通过上面的分析，得到了一种解24点的基本思路，即遍历运算符、数字和括号的 所有排列组合形式，接下来，我们将更加细致地讨论这种解法的一个具体实现。 假设给定的4个数组成的集合为A=&#123;1,2,3,4&#125;，定义函数f(A)为对集合A中的元素进 行所有可能的四则混合运算所得到的值。 首先从集合A中任意取出两个数，如取出1和2, A=A- &#123;1,2&#125;，对取出来的数分别进 行不同的四则运算，1+2=3， 1-2=-1, 1/2=0.5， 1x2=2,将所得的结果再分别加入 集合A，可得到B=&#123;3,3,4&#125;, C=&#123;-1,3,4&#125;, D=&#123;0.5,3,4&#125;, E= &#123;, 3,4&#125;四个新的集合，那么 f(A)=f(B)+f(C)+f(D)+J(E),通过以上的计算就达到了分而治之的目的，问题规模就 从4个数降到了3个数，成了3个数的4个子问题之和。 综上所述，可以得到递归解法为: 首先将给定的4个数放入数组Array中，将其作为参数传入函数f中，伪代码如下: 程序伪代码 123456789101112if (Array. Length &lt; 2) &#123; if (得到的最终结果为24)输出表达式） else（输出无法构造符合要求的表达式） &#125; foreach (从数组中任取两个数的组合) &#123; foreach (运算符( +，一，x, /) ) &#123; 1.计算该组合在此运算符下的结果 2.将该组合中的两个数从原数组中移除，并将步骤1的计算结果放入数 组 3.对新数组递归调用f.如果找到一-个表达式则返回 4.将步骤1的计算结果移除，并将该组合中的两个数重新放回数组中对应的位置 &#125; &#125; 2.关键算法构造 程序流程总图 3.程序实现 papackage www.homework.ChapterThree; import java.io.; import java.util.; public class FourRandomGameExceptionThreadOf24 { private static final int CardsNumber = 4; private static final int ResultValue = 24; private static double number[] = new double[CardsNumber]; private static String result[] = new String[CardsNumber]; private static HashMap&lt;Integer,String&gt; map = new HashMap&lt;&gt;();//存放结果Hash表，key为按递增序列排序的，方便对map的操作 private static int hashSize = 0; private static HashMap&lt;Integer,String&gt; JQKA = new HashMap&lt;&gt;();//存放数字和扑克牌一一对应关系 private static ArrayList str = new ArrayList(); private static Set treeMap = new TreeSet&lt;&gt;();//用存放Person类的信息，方便按照分数由高到底输出 static { JQKA.put(1,“A”); JQKA.put(2,“2”); JQKA.put(3,“3”); JQKA.put(4,“4”); JQKA.put(5,“5”); JQKA.put(6,“6”); JQKA.put(7,“7”); JQKA.put(8,“8”); JQKA.put(9,“9”); JQKA.put(10,“10”); JQKA.put(11,“J”); JQKA.put(12,“Q”); JQKA.put(13,“K”); } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233/** * 对随机的四个数进行递归且24点，穷举了所有可能，将结果存储到map中 * @param n 要递归的操作数的个数 */private static void PointsGame(int n) &#123; if (n == 1) &#123; if (Math.abs(number[0] - ResultValue) == 0) &#123; if (!map.containsValue(result[0])) &#123; map.put(hashSize++,result[0]); &#125; return ; &#125; else &#123; return ; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; double a; double b; String expa; String expb; a = number[i]; b = number[j]; number[j] = number[n - 1]; expa = result[i]; expb = result[j]; result[j] = result[n - 1]; //避免了因交换律产生的多个重复的解 if (a &lt;= b) &#123; result[i] = &apos;(&apos; + expa + &apos;+&apos; + expb + &apos;)&apos;; number[i] = a + b; PointsGame(n - 1); &#125; result[i] = &apos;(&apos; + expa + &apos;-&apos; + expb + &apos;)&apos;; number[i] = a - b; PointsGame(n - 1); result[i] = &apos;(&apos; + expb + &apos;-&apos; + expa + &apos;)&apos;; number[i] = b - a; PointsGame(n - 1); if (a &lt;= b) &#123; result[i] = &apos;(&apos; + expa + &apos;*&apos; + expb + &apos;)&apos;; number[i] = a * b; PointsGame(n - 1); &#125; if (b != 0) &#123; result[i] = &apos;(&apos; + expa + &apos;/&apos; + expb + &apos;)&apos;; number[i] = a / b; PointsGame(n - 1); &#125; if (a != 0) &#123; result[i] = &apos;(&apos; + expb+ &apos;/&apos; + expa + &apos;)&apos;; number[i] = b / a; PointsGame(n - 1); &#125; number[i] = a; number[j] = b; result[i] = expa; result[j] = expb; &#125; &#125;&#125;/** * 简单的开始界面函数 */private static void menu() &#123; System.out.println(&quot;*****************&quot;); System.out.println(&quot;* 24点游戏 *&quot;); System.out.println(&quot;* 1.开始 *&quot;); System.out.println(&quot;* 2.排名 *&quot;); System.out.println(&quot;* 3.结束 *&quot;); System.out.println(&quot;*****************&quot;);&#125;/** * 对用户按照分数进行排序，通过TreeSet集合可以简单的实现，只要向里面存储就行了 * @throws FileNotFoundException */public static void sort() throws FileNotFoundException &#123; Scanner input = new Scanner(new File(&quot;F:\\\\Program\\\\Java\\\\IDEA\\\\Arithmetic\\\\src\\\\www\\\\homework\\\\ChapterThree\\\\TopList.txt&quot;)); //input.useDelimiter(&quot;\\r\\n&quot;); while (input.hasNextLine()) &#123; String scannerRead = input.nextLine(); treeMap.add(new Person(scannerRead.split(&quot; &quot;)[0],Integer.valueOf(scannerRead.split(&quot; &quot;)[1]))); /*for (int i = 0; i &lt; str.size(); i++) &#123; for (int j = i; j &gt;0; j--) &#123; String[] spj = str.get(j).split(&quot; &quot;); String[] spj_1 = str.get((j - 1)).split(&quot; &quot;); if (Integer.valueOf(spj[1]) &gt; Integer.valueOf(spj_1[1])) &#123; String temp = str.get(j); str.set(j,str.get(j - 1)); str.set(j - 1,temp); &#125; &#125; &#125;*/ &#125;&#125;public static void main(String[] args) throws IOException &#123; Scanner input = new Scanner(System.in); int select; while (true) &#123; menu(); System.out.println(&quot;select:&gt;&quot;); select = input.nextInt(); if (select == 3) &#123; break; &#125; else if (select == 2) &#123; sort(); System.out.println(treeMap); &#125; else if (select == 1) &#123; System.out.println(&quot;请输入用户ID:&quot;); input.nextLine(); String ID = input.nextLine(); Person person = new Person(ID); while (person.life != 0) &#123; System.out.println(&quot;随机的4个扑克牌是&quot;); for (int i = 0; i &lt; CardsNumber; i++) &#123; int x = (int) (Math.random() * 13) + 1; if (x &lt;= 10 &amp;&amp; x &gt;= 2) &#123; System.out.print(x + &quot; &quot;); &#125; else &#123; System.out.print(JQKA.get(x) + &quot; &quot;); &#125; number[i] = x; result[i] = JQKA.get(x); &#125; PointsGame(CardsNumber); if (map.size() == 0) &#123; System.out.println(); System.out.println(&quot;这组组合没有解,进行下一组!&quot;); continue; &#125; else &#123; System.out.println(); System.out.println(&quot;答案表如下!&quot;); for (int mapKey : map.keySet() ) &#123; System.out.println(map.get(mapKey)); &#125; &#125; System.out.println(&quot;您有30秒的时间答题！&quot;); System.out.println(&quot;请输入求24点的表达式:&quot;); /** * 倒计时操作 */ int time = 0; new Timer().schedule(new MyTimerTask1(), 2000); // 下面这段代码是每隔1秒,打印下当前的时间 while (true) &#123; try &#123; if (input.hasNext()) &#123;//在有输入的时候提前跳出，判断是否正确 break; &#125; if (++time == 150) &#123; System.out.println(&quot;30秒时间到,进入下一题,减少1个生命值！&quot;); System.out.println(&quot;你还剩下&quot; + (--person.life) + &quot;的生命值！&quot;); System.out.println(&quot;1.继续&quot;); System.out.println(&quot;2.不玩了&quot;); for (int i = hashSize - 1; i &gt;= 0; i--) &#123; map.remove(i); &#125; break; &#125; Thread.sleep(1000);//其实这是一个线程，让程序停滞1秒钟 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //用户再此输入答案 String personResult = input.nextLine(); if (personResult.equals(&quot;1&quot;)) &#123; continue; &#125; else if (personResult.equals(&quot;2&quot;)) &#123; break; &#125; if (map.containsValue(personResult)) &#123; System.out.println(&quot;表达式正确,加10分!进入下一题!&quot;); person.score += 10; &#125; else &#123; System.out.println(&quot;答题错误,进入下一题,减少1个生命值！&quot;); System.out.println(&quot;你还剩下&quot; + (--person.life) + &quot;的生命值！&quot;); &#125; map.clear(); &#125; if (person.life == 0) &#123; System.out.println(&quot;您的生命值已用完,游戏结束!&quot;); &#125; else &#123; System.out.println(&quot;您已结束游戏!&quot;); &#125; System.out.println(&quot;用户:&quot; + person.ID); System.out.println(&quot;分数:&quot; + person.score); //存入文件的操作 File user = new File(&quot;F:\\\\Program\\\\Java\\\\IDEA\\\\Arithmetic\\\\src\\\\www\\\\homework\\\\ChapterThree\\\\TopList.txt&quot;); Writer out = new FileWriter(user,true); Scanner fileScanner = new Scanner(user); ArrayList&lt;String&gt; fileReadStr = new ArrayList&lt;&gt;(); while (fileScanner.hasNextLine()) &#123; fileReadStr.add(fileScanner.nextLine()); &#125; /** * 下面是判断用户是否是之前有过记录的用户 * 如果用具名称相同，只修改他现有的分数即可 * 其实这一部分用HashMap作为数据结构然后结合文件进行操作即可 * 这里是使用字符串切割然后比较的方式 */ int contain = 0; for (int i = 0; i &lt; fileReadStr.size(); i++) &#123; if (fileReadStr.get(i).split(&quot; &quot;)[0].equals(person.ID)) &#123; fileReadStr.set(i,person.ID + &quot; &quot; + person.score + &quot;\\r\\n&quot;); out.write(fileReadStr.get(i)); contain = 1; &#125; else &#123; out.write(fileReadStr.get(i) + &quot;\\r\\n&quot;); &#125; &#125; if (contain == 0) &#123; out.write(person.ID + &quot; &quot; + person.score + &quot;\\r\\n&quot;); &#125; out.close(); &#125; &#125; System.out.println(&quot;游戏结束,祝您生活愉快!&quot;);&#125; } } 4.调试、测试及运行结果 4.1调试截图 前端用户的输入 程序内部变量 number数组是操作数数组，存放生成的随机扑克牌对应的数字 其中result数组是一个String类型的数组中吧保存扑克牌，递归最终result[0]为表达式最终解 我使用了HashMap JQKA作为存储数字和扑克牌之间的一一对应关系，方便对数字运算的时候，对字符串也进行操作 用户类信息， 包括 life：生命 ID：用户ID score：用户的分数 开始递归的模样 过程截图，正在递归 递归的过程中找到了合适的答案 由图所示map中存放的就是所求的答案 如下图所示，找到了新的第4个答案 4.2测试截图 开始界面，选择1进行操作，输入用户名，随机产生数字 随机生成的数的所有答案 答对答案加10分 答错不扣分，减少生命值 当你的生命值用完之后可以选择继续下一个用户，可以结束游戏，也可以查看排名 第一个用户：wangchong答对了两题20分 第二个用户：gaoyangyang对了一题10分 按照分数有低到高排序，这里我是用了TreeSet保存用户自定义的类Person从而达到用户信息不会重复，并且Person类实现了Comparable接口，然后在Person类中重写了compareTo方法，使之按照分数大小排序 在文件中保存的是 5.经验归纳 本次实验，我做了好几个不同的版本，文件夹下面的FourRandomGameExceptionThreeOf24.java是最终的作业版本，里面实现了随机生成的扑克牌并存储所有可能算出二十四点的带有括号的中缀表达式，将这些所有的结果，存储到hash表，这样再用户输入答案的时候，程序可以方便的在hash表中匹配是否有这样的答案，如果有则用户回答正确，如果没有则回答错误。可以方便的为实现游戏功能。 PosExprePro.java实现了中缀表达式求解加减乘除的运算，也就是用栈实现的，只要程序调用这个类，并且传递给最终递归得到的结果就可以轻松的算处是否是24点，但是我并没有采用这个方式计算24点，因为它没有HashMap时间复杂度O(1)的快捷。并且他的两个栈的开销，计算时间也相对较大所以我选择了前者。 AllResultGameOf24.java下的程序是对于求二十四点的所有表达式，包含相同的运算方式但是只是操作数的结合方式不同而已，例如如果四个数的全加法正好等于二十四，那么所有操作数的位置不同，结合方式不同就会产生不同的答案。我认为这样的答案对程序员是不友好的，因为它明明就是一种解法，但是他对用户是非常友好的，因为你并不知道用户是如何输入答案的，作为程序员应该尽可能考虑用户的所有输入可能。 为了让我更加舒服的看程序，我想看看到底四个数可以生成的算二十四点的方式有几种，我设计了产生更纯粹答案的类AllPureResultGameOf24.java 它可以算出来更为纯粹的答案，就明确的得到答案的个数，实现方法很简单，在AllResultGameOf24.java类的基础上，将重复答案去除即可，因为产生重复答案的可能仅仅出现在加法和乘法操作中（因为加法和乘法的操作虽然操作数的位置不同但是结果必然是相同的），在一个答案表达式中，加号或乘号的个数小于3的颠倒操作数的是多种答案可能可以通过当其中其中一个操作数小于等于另外一个操作数的时候在进行加操作或者乘操作。当加号或乘号的个数为3个的时候，我只保留第一出现的这种情况，当第二次出线这种情况事，不保存他，这只需要对答案数组按照加号，或者乘号切分字符串即可，这样他们必然被切分为4个子字符串。 FourRandomGameExceptionThreadOf24.java类下面，在实现倒计时的时候，运用了多线程的功能，即在用户的输入的同时，计时的程序同时也在进行了，运用多线程是非常合适的。 还有一处亮点是在用户类Person.java下面实现了Comparable接口，这样在进行排名的时候就相当的方便了，我只需要吧Person类的相关信息保存在TreeSet集合中，并覆写了CompareTo方法保证按照score（用户分数）由大到小排列，这样，在输出排名信息的时候就直接对TreeSet进行输出即可，这样既能看见用户信息，用对用户的分数进行了排名，一举两得。","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","permalink":"http://yoursite.com/tags/CSDN迁移/"}]},{"title":"模拟图灵机","slug":"模拟图灵机","date":"2019-04-04T12:54:38.000Z","updated":"2019-05-14T06:56:32.995Z","comments":true,"path":"2019/04/04/模拟图灵机/","link":"","permalink":"http://yoursite.com/2019/04/04/模拟图灵机/","excerpt":"","text":"版权声明：wangchong https://blog.csdn.net/wfcn_zyq/article/details/88626808 题目分析 1234567对于扩展二进位的乘2运算比进一位图灵机更为简单。通过如下指令给出图灵机（XN*2） 在扩展的二进位上实现这个运算的指令，实现*2操作0 0 → 0 0R0 1 → 1 0R1 0 → 0 1R1 1 → 10 0R10 0 → 11 1R11 0 → 0 1 STOP 算法构造 12345678用户输入数字，将数字转换为二进制码，将二进制转换为二进制扩展码，通过图灵机（XN*2）实现乘2操作得到结果的二进制扩展码，再将二进制扩展码转换为对应的二进制码，由二进制得十进制结果1.toBinaryString()将整数转换为二进制码2.toBinaryExtend()将二进制码转换为二进制扩展码3.processXNMulitTwo()图灵机（XN*2）实现乘2操作整个过程4.extendToBinary()将二进制扩展码转换为二进制5.binaryToInt()二进制转换为十进制6.printArray()将图灵机的步骤打印STOP 算法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143package EmbarkationTwo;import java.util.Scanner;public class Turing &#123; /** * 实现将一个字符串转换成对应的二进制扩展码 * @param str * @return 返回str的二进制扩展码 */ private static String toBinaryExtend(String str) &#123; char[] arr = str.toCharArray(); if (arr[0] == &apos;0&apos;) &#123; return &quot;0&quot;; &#125; StringBuilder cur = new StringBuilder(); cur = cur.append(&quot;010&quot;); for (int i = 1; i &lt; arr.length; i++) &#123; if (arr[i] == &apos;1&apos;) &#123; cur = cur.append(&quot;10&quot;); &#125; else &#123; cur = cur.append(&quot;0&quot;); &#125; &#125; return cur.append(&quot;110&quot;).toString(); &#125; /** * 打印数组当前状态的值 * @param arr 待打印数组 * @param i 操作到数组中第 i 个字符 * @param state 此时图灵机的状态 */ private static void printArray(char[] arr, int i, int state) &#123; System.out.printf(&quot;第%2d步:&quot;,i + 1); System.out.printf(&quot;内部状态:%-2d 当前值:%c 扩展码:&quot;,state,arr[i]); for (char ch: arr ) &#123; System.out.print(ch); &#125; System.out.println(); &#125; /** * 图灵机实现乘的过程 * @param str 二进扩展码 * @return 对应二进制扩展码的完成乘2之后得到的扩展码 */ private static String processXNMultiTwo(String str) &#123; int state = 0; char[] arr = str.toCharArray(); for (int i = 0; i &lt; arr.length; i++) &#123; if (state == 0 &amp;&amp; arr[i] == &apos;0&apos;) &#123; printArray(arr,i,state); arr[i] = &apos;0&apos;; state = 0; &#125; else if (state == 0 &amp;&amp; arr[i] == &apos;1&apos;) &#123; printArray(arr,i,state); arr[i] = &apos;0&apos;; state = 1; &#125; else if (state == 1 &amp;&amp; arr[i] == &apos;0&apos;) &#123; printArray(arr,i,state); arr[i] = &apos;1&apos;; state = 0; &#125; else if (state == 1 &amp;&amp; arr[i] == &apos;1&apos;) &#123; printArray(arr,i,state); arr[i] = &apos;0&apos;; state = 10; &#125; else if (state == 10 &amp;&amp; arr[i] == &apos;0&apos;) &#123; printArray(arr,i,state); arr[i] = &apos;1&apos;; &#125; &#125; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; arr.length; i++) &#123; sb.append(arr[i]); &#125; sb.append(&quot;1&quot;); printArray(sb.toString().toCharArray(),arr.length,11); sb.append(&quot;0&quot;); printArray(sb.toString().toCharArray(),arr.length + 1,0); System.out.println(&quot;STOP&quot;); return sb.toString(); &#125; /** * 求一个字符串对应的二进制 * @param str 待求二进制的字符串 * @return str的二进制表示 */ private static String extendToBinary(String str) &#123; char[] arr = str.toCharArray(); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; arr.length; i++) &#123; if (arr[i] == &apos;1&apos; &amp;&amp; arr[i + 1] == &apos;0&apos;) &#123; sb.append(&apos;1&apos;); &#125; else if ((i + 1) &lt; arr.length &amp;&amp; arr[i] == &apos;0&apos; &amp;&amp; arr[i + 1] == &apos;0&apos;) &#123; sb.append(&apos;0&apos;); &#125; else if (arr[i] == &apos;1&apos; &amp;&amp; arr[i + 1] == &apos;1&apos;) &#123; sb.append(&apos;,&apos;); i++; &#125; &#125; return sb.toString(); &#125; /** * 求一个字符串(二进制)的整数形式 * @param str 待求整数的二进制字符串 * @return str的对应的十进制整数 */ private static int binaryToInt(String str) &#123; int n = str.length() - 1; String indexStr = str.substring(0,str.length() - 1); char[] arr = indexStr.toCharArray(); int sum = 0; boolean judge = false; for (int i = 0; i &lt; arr.length; i++) &#123; if (arr[i] == &apos;1&apos;) &#123; judge = true; &#125; if (judge) &#123; sum += (arr[i] - 48) * Math.pow(2,n - i - 1); &#125; &#125; return sum; &#125; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;通过图灵机(XN * 2) 的方式在扩展的二进位上实现 * 2操作&quot;); System.out.print(&quot;输入一个整数:&quot;); int before = input.nextInt(); String beforeStr = Integer.toBinaryString(before); String beforeBinaryExtend = toBinaryExtend(beforeStr); String afterBinaryExtend = processXNMultiTwo(beforeBinaryExtend); System.out.println(&quot;最终的扩展码:&quot; + afterBinaryExtend); String afterBinary = extendToBinary(afterBinaryExtend); System.out.println(&quot;最终的二进制码:&quot; + afterBinary); int afterResult = binaryToInt(afterBinary); System.out.println(&quot;最终值:&quot; + afterResult); &#125;&#125; 经验归纳 123通过对图灵机的模拟我深刻的了解了当时计算机进行运算的整体过程，感受到人也可以和机器交流，深深的感受到代码的魅力，没有当时的图灵机思想计算机不可能实现运算操作。 图灵机证明了通用计算理论，肯定了计算机实现的可能性，同时它给出了计算机应有的主要架构；图灵机模型引入了读写与算法与程序语言的概念，极大的突破了过去的计算机器的设计理念；图灵机模型理论是计算学科最核心的理论，因为计算机的极限计算能力就是通用图灵机的计算能力，很多问题可以转化到图灵机这个简单的模型来考虑。因为我使用Java写的结合方法的封装性实现了toBinaryString()将整数转换为二进制码，toBinaryExtend()将二进制码转换为二进制扩展码，processXNMulitTwo()图灵机（XN*2）实现乘2操作整个过程，extendToBinary()将二进制扩展码转换为二进制，binaryToInt()二进制转换为十进制，printArray()将图灵机的步骤打印使代码的可读性和实用性大大增加。我体会到了结构化封装的重要性和必要性。","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","permalink":"http://yoursite.com/tags/CSDN迁移/"}]},{"title":"求N个数的最大公约数和最小公倍数。","slug":"求N个数的最大公约数和最小公倍数。","date":"2019-04-04T12:54:25.000Z","updated":"2019-05-14T06:56:39.423Z","comments":true,"path":"2019/04/04/求N个数的最大公约数和最小公倍数。/","link":"","permalink":"http://yoursite.com/2019/04/04/求N个数的最大公约数和最小公倍数。/","excerpt":"","text":"版权声明：wangchong https://blog.csdn.net/wfcn_zyq/article/details/88697857 一. 题目分析 求N个数的最大公约数和最小公倍数。 可以通过递归的方法实现一个接着一个的方法调用求N个数的最大公约数 二.算法设计思路 2.1方法注释 2.1.1求最大公因数 1234567891011/** * 辗转相除法的递归调用 * @param a 整数1 * @param b 整数2 * @return a,b的最大公约数 */private static int gcd(int a , int b) &#123; if(a % b == 0) return b; return gcd( b,a % b);&#125; 2.1.2求最小公倍数 1234567891011/** * * @param a 整数1 * @param b 整数2 * @return a,b的最小公倍数 */private static int multiple(int a, int b) &#123; int temp; temp = gcd(a,b); return (a * b/temp);&#125; 2.1.3输入检查 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 获取正确的输入数据 * @return 一个数组，包含n个数，这两个数输入正确的输入格式，可以用来求最大公约数，和最小公倍数 */private static int[] getLegalFormat() &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;Input n:&quot;); int n = input.nextInt(); int[] arr = new int[n]; boolean judge = true; String str[] = new String[n]; for (int i = 0; i &lt; n; i++) &#123; str[i] = null; &#125; int[] numStr = new int[n]; for (int i = 0; i &lt; n; i++) &#123; numStr[i] = 0; &#125; //对输入异常的处理 while (judge) &#123; System.out.println(&quot;Please input n numbers:&quot;); for (int i = 0; i &lt; n; i++) &#123; str[i] = input.next(); &#125; try &#123; for (int i = 0; i &lt; n; i++) &#123; Integer.parseInt(str[i]); &#125; &#125; catch (NumberFormatException e) &#123; System.out.println(&quot;The input format is wrong, please input again!&quot;); e.printStackTrace(); continue; &#125; for (int i = 0; i &lt; n; i++) &#123; numStr[i] = Integer.parseInt(str[i]); &#125; int positiveNum = 0; for (int i = 0; i &lt; n; i++) &#123; if (numStr[i] &lt; 1) &#123; System.out.println(&quot;You must input two positive integers!Input again!&quot;); judge = true; positiveNum++; break; &#125; &#125; if (positiveNum &gt; 0) &#123; continue; &#125; judge = false; &#125; for (int i = 0; i &lt; n; i++) &#123; arr[i] = Integer.parseInt(str[i]); &#125; return arr;&#125; 3.经验归纳 123456789求N个数的的最大公约数和最小公倍数，一般都是求两个数的，但是N个数怎么求呢？想到递归。算法的核心在于for (int i = 2; i &lt; input.length; i++) &#123; gcdResult = gcd(gcd(input[i - 2], input[i - 1]), input[i]); multipleResult = multiple(multiple(input[i - 2],input[i - 1]), input[i]);&#125;这一个递归调用我们可以通过先算前两个的公约数在用前两个的公约数求后面的公约数，这样求出来的结果就是他们的公约数。通过这次作业，我对递归的算法理解更加深刻了。","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","permalink":"http://yoursite.com/tags/CSDN迁移/"}]},{"title":"Hankson问题","slug":"Hankson问题","date":"2019-04-04T12:53:58.000Z","updated":"2019-05-14T07:06:48.640Z","comments":true,"path":"2019/04/04/Hankson问题/","link":"","permalink":"http://yoursite.com/2019/04/04/Hankson问题/","excerpt":"","text":"版权声明：wangchong https://blog.csdn.net/wfcn_zyq/article/details/88697716 1.题目描述 123456789101112131415161718Hanks博士是BT（Bio-Tech，生物技术）领域的知名专家，他的儿子名叫Hankson。现在，刚刚放学回家的Hankson正在思考一个有趣的问题。今天在课堂上，老师讲解了如何求两个正整数c1和c2的最大公约数和最小公倍数。现在Hankson认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数a0,a1,b0,b1，设某未知正整数x满足：1、 x和a0的最大公约数是a1；2、 x和b0的最小公倍数是b1。Hankson的“逆问题”就是求出满足条件的正整数x。但稍加思索之后，他发现这样的x并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的x的个数。请你帮助他编程求解这个问题。输入格式 输入第一行为一个正整数n，表示有n组输入数据。接下来的n行每行一组输入数据，为四个正整数a0，a1，b0，b1，每两个整数之间用一个空格隔开。输入数据保证a0能被a1整除，b1能被b0整除。输出格式输出共n行。每组输入数据的输出结果占一行，为一个整数。对于每组数据：若不存在这样的x，请输出0；若存在这样的x，请输出满足条件的x的个数；样例输入241 1 96 28895 1 37 1776样例输出62 2.算法设计思路 2.1方法注释 2.1.1求最大公因数 1234567891011/** * 辗转相除法的递归调用 * @param a 整数1 * @param b 整数2 * @return a,b的最大公约数 */private static int gcd(int a , int b) &#123; if(a % b == 0) return b; return gcd( b,a % b);&#125; 2.1.2求最小公倍数 123456789/** * * @param a 整数1 * @param b 整数2 * @return a,b的最小公倍数 */private static int multiple(int a, int b) &#123; return (a * b / gcd(a,b));&#125; 2.1.3输入检查 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 获取正确的输入数据 * @return 一个数组，包含n个数，这两个数输入正确的输入格式，可以用来求最大公约数，和最小公倍数 */ private static int[] getLegalFormat() &#123; Scanner input = new Scanner(System.in); int[] arr = new int[4]; boolean judge = true; String str[] = new String[4]; for (int i = 0; i &lt; 4; i++) &#123; str[i] = null; &#125; int[] numStr = new int[4]; for (int i = 0; i &lt; 4; i++) &#123; numStr[i] = 0; &#125; //对输入异常的处理 while (judge) &#123; for (int i = 0; i &lt; 4; i++) &#123; str[i] = input.next(); &#125; try &#123; for (int i = 0; i &lt; 4; i++) &#123; Integer.parseInt(str[i]); &#125; &#125; catch (NumberFormatException e) &#123; System.out.println(&quot;The input format is wrong, please input again!&quot;); e.printStackTrace(); continue; &#125; for (int i = 0; i &lt; 4; i++) &#123; numStr[i] = Integer.parseInt(str[i]); &#125; for (int i = 0; i &lt; 4; i++) &#123; if (numStr[i] &lt; 1) &#123; System.out.println(&quot;You must input two positive integers!Input again!&quot;); judge = true; continue; &#125; &#125; if (numStr[0] % numStr[1] != 0 &amp;&amp; numStr[3] % numStr[2] != 0) &#123; System.out.println(&quot;You must ensure a0 % a1 == 0 and b1 % b0 == 0.&quot;); continue; &#125; else &#123; judge = false; &#125; &#125; for (int i = 0; i &lt; 4; i++) &#123; arr[i] = Integer.parseInt(str[i]); &#125; return arr;&#125; 2.1.4插入排序 12345678910111213141516/** * 插入排序 * @param arr 待排序数组 */private static void insertionSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = i; j &gt; 0; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; swap(arr,j,j-1); &#125; &#125; &#125;&#125; 2.1.5交换两个数的值 1234567891011/** * 交换数组中两个数的值 * @param arr 数组 * @param i 位置 i * @param j 位置 j */private static void swap(int[] arr, int i,int j) &#123; arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j];&#125; 2.1.6拷贝数组 12345678910/** * 拷贝数组 * @param arr 源数组 * @return arr的数组拷贝 */private static int[] copyArray(int[] arr) &#123; int[] res = new int[arr.length]; System.arraycopy(arr, 0, res, 0, arr.length); return res;&#125; 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153package ChapterTwo;import java.util.Scanner;public class HanksonRight &#123; /** * 辗转相除法的递归调用 * @param a 整数1 * @param b 整数2 * @return a,b的最大公约数 */ private static int gcd(int a , int b) &#123; if(a % b == 0) return b; return gcd( b,a % b); &#125; /** * * @param a 整数1 * @param b 整数2 * @return a,b的最小公倍数 */ private static int multiple(int a, int b) &#123; return (a * b / gcd(a,b)); &#125; /** * 求x的个数 * @param a0 a0 * @param a1 a1 * @param b0 b0 * @param b1 b1 * @param max max * @return 满足条件的x的个数 */ private static int getCount(int a0, int a1, int b0, int b1,int max) &#123; int count = 0; for (int x = 1; x &lt;= max; x++) &#123; if(gcd(x,a0) == a1 &amp;&amp; multiple(x,b0) == b1) count++; &#125; return count; &#125; /** * 插入排序 * @param arr 待排序数组 */ private static void insertionSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = i; j &gt; 0; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; swap(arr,j,j-1); &#125; &#125; &#125; &#125; /** * 交换数组中两个数的值 * @param arr 数组 * @param i 位置 i * @param j 位置 j */ private static void swap(int[] arr, int i,int j) &#123; arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j]; &#125; /** * 拷贝数组 * @param arr 源数组 * @return arr的数组拷贝 */ private static int[] copyArray(int[] arr) &#123; int[] res = new int[arr.length]; System.arraycopy(arr, 0, res, 0, arr.length); return res; &#125; /** * 获取正确的输入数据 * @return 一个数组，包含n个数，这两个数输入正确的输入格式，可以用来求最大公约数，和最小公倍数 */ private static int[] getLegalFormat() &#123; Scanner input = new Scanner(System.in); int[] arr = new int[4]; boolean judge = true; String str[] = new String[4]; for (int i = 0; i &lt; 4; i++) &#123; str[i] = null; &#125; int[] numStr = new int[4]; for (int i = 0; i &lt; 4; i++) &#123; numStr[i] = 0; &#125; //对输入异常的处理 while (judge) &#123; for (int i = 0; i &lt; 4; i++) &#123; str[i] = input.next(); &#125; try &#123; for (int i = 0; i &lt; 4; i++) &#123; Integer.parseInt(str[i]); &#125; &#125; catch (NumberFormatException e) &#123; System.out.println(&quot;The input format is wrong, please input again!&quot;); e.printStackTrace(); continue; &#125; for (int i = 0; i &lt; 4; i++) &#123; numStr[i] = Integer.parseInt(str[i]); &#125; for (int i = 0; i &lt; 4; i++) &#123; if (numStr[i] &lt; 1) &#123; System.out.println(&quot;You must input two positive integers!Input again!&quot;); judge = true; continue; &#125; &#125; if (numStr[0] % numStr[1] != 0 &amp;&amp; numStr[3] % numStr[2] != 0) &#123; System.out.println(&quot;You must ensure a0 % a1 == 0 and b1 % b0 == 0.&quot;); continue; &#125; else &#123; judge = false; &#125; &#125; for (int i = 0; i &lt; 4; i++) &#123; arr[i] = Integer.parseInt(str[i]); &#125; return arr; &#125; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;Input n:&quot;); int n = input.nextInt(); int[] result = new int[n]; System.out.println(&quot;Input &quot; + n + &quot; row numbers(row by 4 cols,ensure a0 % a1 == 0 and b1 % b0 == 0):&quot; ); for (int i = 0; i &lt; result.length; i++) &#123; int[] data = getLegalFormat(); int[] arr = copyArray(data); insertionSort(data); result[i] = getCount(arr[0],arr[1],arr[2],arr[3],data[data.length - 1]); &#125; for (int aResult : result) &#123; System.out.println(aResult); &#125; &#125;&#125; 3.经验归纳 1234567891011解题的时候最重要，找到解题的方法，本题的方法，在于只要找到输入的4个数中最大的值，然后x的值一定小于最大值，因为a0 % a1 == 0 and b1 % b0 == 0，知道这个之后，就可以先将输入的数组拷贝到另外一个数组中，然后将原数组排序，找到最大值，并设计以下方法private static int getCount(int a0, int a1, int b0, int b1,int max) &#123; int count = 0; for (int x = 1; x &lt;= max; x++) &#123; if(gcd(x,a0) == a1 &amp;&amp; multiple(x,b0) == b1) count++; &#125; return count;&#125;用来计数。从而可以看出解题的关键在于找到解决问题的方法。","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","permalink":"http://yoursite.com/tags/CSDN迁移/"}]},{"title":"给定两个正整数，求它们的最大公约数。","slug":"给定两个正整数，求它们的最大公约数。","date":"2019-03-09T15:26:53.000Z","updated":"2019-05-14T06:56:52.525Z","comments":true,"path":"2019/03/09/给定两个正整数，求它们的最大公约数。/","link":"","permalink":"http://yoursite.com/2019/03/09/给定两个正整数，求它们的最大公约数。/","excerpt":"","text":"版权声明：wangchong https://blog.csdn.net/wfcn_zyq/article/details/88254340 要求 1234给定两个正整数，求它们的最大公约数。分别使用辗转相除法，更相减损法，穷举法，Stein算法，实现最大公约数或最小公倍数的求解，至少比较4种GCD算法在给定不同规模测试数据的情况下的平均运行时间。 算法实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410package EmbarkationOne;/*** @describe* @file Gcd* @author wangchong* @date 2019/3/5 * @params * @return * @email 876459397@qq.com* @CSDN https://blog.csdn.net/wfcn_zyq*/import java.util.Arrays;import java.util.HashMap;import java.util.Scanner;/** * Sopwatch 创建对象时会直接记录创建的时间 * elapsedTime() 返回Soapwatch自创建到调用这个函数这个期间经历的纳秒数 */class Stopwatch &#123; private final long start; public Stopwatch() &#123; start = System.nanoTime(); &#125; public double elapsedTime() &#123; long now = System.nanoTime(); return (now - start); &#125;&#125;public class Gcd &#123; /** * 其算法过程为： 前提：设两数为a,b设其中a 做被除数,b做除数，temp为余数 * 1、大数放a中、小数放b中； * 2、求a/b的余数； * 3、若temp=0则b为最大公约数； * 4、如果temp!=0则把b的值给a、temp的值给a； * 5、返回第二步； * @param a * @param b * @return 最大公约数 */ private static int divisor(int a, int b) &#123; int temp; if(a &lt; b) &#123; temp = a; a = b; b = temp; &#125; while(b != 0) &#123; temp = a % b; a = b; b = temp; &#125; return a; &#125; /** * * @param a * @param b * @return a,b的最小公倍数 */ private static int multiple(int a, int b) &#123; int temp; temp = divisor(a,b); return (a * b/temp); &#125; /** * 辗转相除法的递归调用 * @param a * @param b * @return a,b的最大公约数 */ private static int gcd(int a, int b) &#123; if(a % b == 0) &#123; return b; &#125; else &#123; return gcd(b,a%b); &#125; &#125; /** * 穷举法（也叫枚举法）穷举法求两个正整数的最大公约数的解题步骤： * 从两个数中较小数开始由大到小列举， * 直到找到公约数立即中断列举，得到的公约数便是最大公约数 。 * 对两个正整数a,b如果能在区间[a,0]或[b,0]内能找到一个整数temp * 能同时被a和b所整除，则temp即为最大公约数。 * @param a * @param b * @return a,b的最大公约数 */ private static int enumerateDivisor(int a, int b) &#123; int temp = a &gt; b ? b : a; while (temp &gt; 0) &#123; if (a % temp == 0 &amp;&amp; b % temp == 0) &#123; break; &#125; temp--; &#125; return temp; &#125; /** * 枚举法求对两个正整数a,b的最小公倍数 * 如果若干个a之和或b之和能被b所整除或能被a所整除， * 则该和数即为所求的最小公倍数。 * @param a * @param b * @return a,b的最小公倍数 */ private static int addMultiple(int a, int b) &#123; int max = a &gt; b ? a : b; int min = a &gt; b ? b : a; int temp = max; while (true) &#123; if (max % min == 0) &#123; break; &#125; max += temp; &#125; return max; &#125; /** * 更小减损法求两个数的最大公因数 * 第一步：任意给定两个正整数；判断它们是否都是偶数。 * 若是，则用2约简；若不是则执行第二步。 * 第二步：以较大的数减较小的数，接着把所得的差与较小的数比较， * 并以大数减小数。继续这个操作，直到所得的减数和差相等为止。 * 则第一步中约掉的若干个2与第二步中等数的乘积就是所求的最大公约数。 * 其中所说的“等数”，就是最大公约数。求“等数”的办法是“更相减损”法。 * 所以更相减损法也叫等值算法。 * @param a * @param b * @return a,b的最大公约数 */ private static int GCDDivisor(int a ,int b) &#123; while (a!=b) &#123; if (a&gt;b) &#123; a -= b; &#125; else &#123; b-=a; &#125; &#125; return a; &#125; /** * stein算法 * 1.均为偶数 gcd( x,y ) =2gcd( x/2,y/2 )； * 2.均为奇数 gcd( x,y ) = gcd( (x+y)/2,(x-y)/2 )； * 2.x奇y偶 gcd( x,y ) = gcd( x,y/2 )； * 3.x偶y奇 gcd( x,y ) = gcd( x/2,y ) 或 gcd( x,y )=gcd( y,x/2 )； * @param x * @param y * @return x,y的最大公因数 */ private static int stein(int x, int y) &#123; int factor = 0; int temp; if (x &lt; y) &#123; temp = x; x = y; y = temp; &#125; if (0 == y) &#123; return 0; &#125; while (x != y) &#123; if (!isEvenNumber(x &amp; 0x1)) &#123; if (!isEvenNumber(y &amp; 0x1)) &#123; y = (x - y) &gt;&gt; 1; x -= y; &#125; else &#123; y &gt;&gt;= 1; &#125; &#125; else &#123; if (!isEvenNumber(y &amp; 0x1)) &#123; x &gt;&gt;= 1; if (x &lt; y) &#123; temp = x; x = y; y = temp; &#125; &#125; else &#123; x &gt;&gt;= 1; y &gt;&gt;= 1; ++factor; &#125; &#125; &#125; return(x &lt;&lt; factor); &#125; /** * stein的递归调用 * @param u * @param v * @return u,v的最大公因数 */ private static int steinRecursion(int u, int v) &#123; if (u == 0) &#123; return v; &#125; if(v == 0) &#123; return u; &#125; if(!isEvenNumber(~u &amp; 1)) &#123; if(!isEvenNumber(v &amp; 1)) &#123; return steinRecursion(u &gt;&gt; 1,v); &#125; else &#123; return steinRecursion(u &gt;&gt; 1,v &gt;&gt; 1) &lt;&lt; 1; &#125; &#125; if(!isEvenNumber(~v &amp; 1)) &#123; return steinRecursion(u,v &gt;&gt; 1); &#125; if(u &gt; v) &#123; return steinRecursion((u - v) &gt;&gt; 1,v); &#125; return steinRecursion((v - u) &gt;&gt; 1,u); &#125; /** * 求n是否为偶数 * @param n * @return n为偶数返回true，否则返回false */ private static boolean isEvenNumber(int n) &#123; return (((n &gt;&gt; 1) &lt;&lt; 1) == n); &#125; /** * * @param maxSize * @param maxValue * @return 返回一个二维数组，maxSize行，2列，数组中的每个数都是随机的，随机大小在[0,maxValue]范围内 */ public static int[][] generateRandomArray(int maxSize,int maxValue) &#123; int[][] arr = new int[maxSize][2]; for (int i = 0; i &lt; maxSize; i++) &#123; for (int j = 0; j &lt; 2; j++) &#123; arr[i][j] = (int) ((maxValue + 1) * Math.random()) + 1; &#125; &#125; return arr; &#125; /** * * @param arr * @param select * @return 返回对应select的求最大公因数或最小公倍数函数的运行时间， */ public static double runTime(int[][] arr, int select) &#123; //创建Stopwatch变量，记录他常见开始时间 Stopwatch timer = new Stopwatch(); for (int i = 0; i &lt; arr.length; i++) &#123; switch (select) &#123; case 1: divisor(arr[i][0],arr[i][1]); break; case 2: gcd(arr[i][0],arr[i][1]); break; case 3: enumerateDivisor(arr[i][0],arr[i][1]); break; case 4: GCDDivisor(arr[i][0],arr[i][1]); break; case 5: stein(arr[i][0],arr[i][1]); break; case 6: steinRecursion(arr[i][0],arr[i][1]); break; case 7: addMultiple(arr[i][0],arr[i][1]); break; case 8: multiple(arr[i][0],arr[i][1]); break; &#125; &#125; //调用函数elapsedTime()返回从创建开始到结束的时间 return timer.elapsedTime(); &#125; /** * 输入i对应的函数的输出信息提示 * @param i */ public static void printTime(int i) &#123; switch (i) &#123; case 1: System.out.print(&quot;Time of divisor is:&quot;); break; case 2: System.out.print(&quot;Time of gcd is:&quot;); break; case 3: System.out.print(&quot;Time of enumerateDivisor is:&quot;); break; case 4: System.out.print(&quot;Time of GCDDivisor is:&quot;); break; case 5: System.out.print(&quot;Time of stein is:&quot;); break; case 6: System.out.print(&quot;Time of steinRecursion is:&quot;); break; case 7: System.out.print(&quot;Time of addMultiple is:&quot;); break; case 8: System.out.print(&quot;Time of multiple is:&quot;); break; &#125; &#125; /** * 获取正确的输入数据 * @return 一个数组，包含两个数，这两个数输入正确的输入格式，可以用来求最大公约数，和最小公倍数 */ public static int[] getlegalFormat() &#123; Scanner input = new Scanner(System.in); int[] arr = new int[2]; boolean judge = true; String str1 = null, str2 = null; int num1,num2; //对输入异常的处理 while (judge) &#123; System.out.println(&quot;Please input two numbers:&quot;); str1 = input.next(); str2 = input.next(); try &#123; Integer.parseInt(str1); Integer.parseInt(str2); &#125; catch (NumberFormatException e) &#123; judge = true; System.out.println(&quot;The input format is wrong, please input again!&quot;); e.printStackTrace(); continue; &#125; num1 = Integer.parseInt(str1); num2 = Integer.parseInt(str2); if (num1 &lt; 1 || num2 &lt; 1) &#123; System.out.println(&quot;You must input two positive integers!Input again!&quot;); judge = true; continue; &#125; judge = false; &#125; arr[0]= Integer.parseInt(str1); arr[1] = Integer.parseInt(str2); return arr; &#125; public static void main(String[] args) &#123; int[] input = getlegalFormat(); //输出对输入数据的求取最大公约数，或者最小公倍数 System.out.println(&quot;divisor is:&quot; + divisor(input[0],input[1]) ); System.out.println(&quot;gcd is:&quot; + gcd(input[0],input[1]) ); System.out.println(&quot;enumerateDivisor is:&quot; + enumerateDivisor(input[0],input[1]) ); System.out.println(&quot;stein is:&quot; + stein(input[0],input[1]) ); System.out.println(&quot;steinRecursion is:&quot; + steinRecursion(input[0],input[1]) ); System.out.println(&quot;addMultiple is:&quot; + addMultiple(input[0],input[1]) ); System.out.println(&quot;multiple is:&quot; + multiple(input[0],input[1]) ); int maxValue = 100000; double[] sumTime = new double[8]; //5组数据 for (int i = 1; i &lt;= 5; i++) &#123; int maxSize = 2000 * i; System.out.printf(&quot;Values of %d&quot;,maxSize); System.out.println(); System.out.println(&quot;**********************************&quot;); int[][] arr = generateRandomArray(maxSize,maxValue); for (int j = 1; j &lt;= 8; j++) &#123; printTime(j); sumTime[j - 1] += runTime(arr,j); System.out.println(runTime(arr,j) + &quot;ns&quot;); &#125; System.out.println(&quot;**********************************&quot;); &#125; System.out.println(&quot;Average time is (sort from smallest to biggest )&quot;); //创建hash表，处理对应的函数信息，和运行时间意义对应 HashMap&lt;Double, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 1; i &lt;= 8; i++) &#123; map.put(sumTime[i - 1],i); &#125; Arrays.sort(sumTime); for (int i = 0; i &lt; 8; i++) &#123; printTime(map.get(sumTime[i])); System.out.println(sumTime[i] / 5 + &quot;ns&quot;); &#125; System.out.println(&quot;**********************************&quot;); &#125;&#125; 调试、测试及运行结果 调试 123输入含有字符串而不是数字(测试部分将会显示更加全面的输入检查)这个时候会报错提示你重新输入，因为你无法，对一个字符串求它和谁的公约数，设置一个judge变量，当judge为true的时候就会重新回到输入的请求直到输入正确的时候 输入正确的时候 123456 程序继续运行将会计算每个函数的运行时间，这里我通过hash表的方式存储时间，以方便在排序的时候将他们按照顺序输出到屏幕上，以保证更清晰的观察。 根据分别给函数20000组，每次增加20000组数据的方式测试求最大公约数，对相同组，相同的数据的进行计算所花费的时间。 我通过设置maxValue的值为100000，生成[0,100000]范围内的任意一个数，任意一对数组成一组数据，用来测试求每组数据求最大公约数。 最后由小到大的时间排序显示出不同算法运行时间上的差别，从而体现出算法的优劣性 5组数据下来，算法执行的总时间（单位：ns）将各个函数运行所需要的时间按照从小到大的顺序输出，可以直观的看出各个算法所用时间的差别 测试 输入异常检查 12345678910111213141516输入是负数，提示重新输入输入是汉字和数字，会报NumberFormatException异常，并重新输入，因为，当设置输入是字符串的时候调用Integer.parseInt()转换为数字的时候，会检查，非纯数字的情况输入是纯汉字，相同的原理，转换成数字的时候报错，提示重新输入。输入是字符串(字母)和数字，与前面是相同的原理，提示错误，并重新输入。输入是字符串和数字的组合型，与前面是相同的原理，提示错误，并重新输入。输入正确，进行下面操作测试数据分别是2000，4000.6000,8000,10000组数据，运行时间用纳秒计算。最后按照运行时间从小到大排序、 测试代码 检测generateRandomArray()函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package EmbarkationOne;public class Test &#123; public static void printArray(int[][] arr) &#123; if (arr == null) &#123; return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr[i].length; j++) &#123; System.out.print(arr[i][j] + &quot; &quot;); &#125; &#125; &#125; /** * * @param maxSize * @param maxValue * @return 返回一个二维数组，maxSize行，2列，数组中的每个数都是随机的，随机大小在[0,maxValue]范围内 */ public static int[][] generateRandomArray(int maxSize,int maxValue) &#123; int[][] arr = new int[maxSize][2]; for (int i = 0; i &lt; maxSize; i++) &#123; for (int j = 0; j &lt; 2; j++) &#123; arr[i][j] = (int) ((maxValue + 1) * Math.random()) + 1; &#125; &#125; return arr; &#125; public static void main(String[] args) &#123; int[][] arr = generateRandomArray(200,100000); printArray(arr); &#125;&#125; **检测getlegalFormat()函数**package EmbarkationOne;import java.util.Scanner;public class TestOne &#123; /** * 获取正确的输入数据 * @return 一个数组，包含两个数，这两个数输入正确的输入格式，可以用来求最大公约数，和最小公倍数 */ public static int[] getlegalFormat() &#123; Scanner input = new Scanner(System.in); int[] arr = new int[2]; boolean judge = true; String str1 = null, str2 = null; int num1,num2; //对输入异常的处理 while (judge) &#123; System.out.println(&quot;Please input two numbers:&quot;); str1 = input.next(); str2 = input.next(); try &#123; Integer.parseInt(str1); Integer.parseInt(str2); &#125; catch (NumberFormatException e) &#123; judge = true; System.out.println(&quot;The input format is wrong, please input again!&quot;); e.printStackTrace(); continue; &#125; num1 = Integer.parseInt(str1); num2 = Integer.parseInt(str2); if (num1 &lt; 1 || num2 &lt; 1) &#123; System.out.println(&quot;You must input two positive integers!Input again!&quot;); judge = true; continue; &#125; judge = false; &#125; arr[0]= Integer.parseInt(str1); arr[1] = Integer.parseInt(str2); return arr; &#125; public static void main(String[] args) &#123; int[] arr = getlegalFormat(); for (int a: arr) &#123; System.out.println(a); &#125; &#125;&#125; 经验归纳 123456789101112131.深入学习了利用不同的算法来解决求解两个正整数的最大公约数和最小公倍数，利用穷举法计算的效率比较低，从测试中可以看出，穷举法比最快的辗转相除法运行时间慢100倍左右，设置测试数据时，设置一个独立的generateRandomArray()获得一个随机数组，通过主程序传的maxSize(组别的大小)，和maxValue(随机数最大值)，来实现样本的输入以后可以进行深入的学习。2.用Java写体现了Java语言特性，有很多优越性，比如，室友都是用C/C++写的，他们在处理时间这一方面没有Java遍历，用Java的elapsedTime() 返回Soapwatch自创建到调用这个函数这个期间经历的纳秒数，纳秒级别的显示更能清晰的看出程序的运行状况，因为目前的计算机计算速度很快，一个小算法，处理成万上前的数据，也只需要ns甚至更小的时间就可以完成。3.在处理比较算法优劣性的方面，我使用了hash表的方式存储函数和对应处理的时间，这样可以在通过排序算法，排序程序运行的时间的同时，可以方便的找到对应的函数信息，这样就比较便利的找到对应的函数，我觉得使用hash表，是再合适不过的了。","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","permalink":"http://yoursite.com/tags/CSDN迁移/"}]},{"title":"LeetCode 206. 反转链表","slug":"LeetCode 206. 反转链表","date":"2019-03-03T09:03:19.000Z","updated":"2019-05-14T06:55:53.437Z","comments":true,"path":"2019/03/03/LeetCode 206. 反转链表/","link":"","permalink":"http://yoursite.com/2019/03/03/LeetCode 206. 反转链表/","excerpt":"","text":"版权声明：wangchong https://blog.csdn.net/wfcn_zyq/article/details/88090434 题目描述 1234反转一个单链表。示例:输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 思路 12345设置一个之前节点pre用来指向每次反转的头结点设置一个下一个节点next 用来保存下一个节点保证可以找到之后的节点head节点每走一步反转一次当走到尾部的时候，反转结束返回pre即可 实现 123456789101112131415161718192021/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode pre = null; ListNode next = null; while (head != null) &#123; next = head.next; head.next = pre; pre = head; head = next; &#125; return pre; &#125;&#125; 小结 1能用几行代码实现这个功能无疑是强大的 欢迎加我QQ：1939765238一起讨论算法","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","permalink":"http://yoursite.com/tags/CSDN迁移/"}]},{"title":"LeetCode 876. 链表的中间结点","slug":"LeetCode 876. 链表的中间结点","date":"2019-03-03T08:52:20.000Z","updated":"2019-05-14T06:55:57.050Z","comments":true,"path":"2019/03/03/LeetCode 876. 链表的中间结点/","link":"","permalink":"http://yoursite.com/2019/03/03/LeetCode 876. 链表的中间结点/","excerpt":"","text":"版权声明：wangchong https://blog.csdn.net/wfcn_zyq/article/details/88090162 题目描述 12给定一个带有头结点 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。 示例 1： 12345输入：[1,2,3,4,5]输出：此列表中的结点 3 (序列化形式：[3,4,5])返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。注意，我们返回了一个 ListNode 类型的对象 ans，这样：ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL. 示例 2： 123输入：[1,2,3,4,5,6]输出：此列表中的结点 4 (序列化形式：[4,5,6])由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 思路 123456789设置两个指针，一个指针一次走一步，一个指针一次走2步当链表大小为奇数-走两步的节点到尾部的时候，走一步的到中间位置当链表大小为偶数-走两步的节点到尾部走一步的到第二个中间节点当链表只有一个节点时-直接返回该节点当链表有两个节点时-返回第一个节点的下一个节点 解法 1234567891011121314151617181920class Solution &#123; public ListNode middleNode(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode n1 = head; ListNode n2 = head; //奇数的时候来到中点，偶数的时候来到中点前面的一个的位置 while (n2.next != null &amp;&amp; n2.next.next != null) &#123; n1 = n1.next; // n1 -&gt; mid n2 = n2.next.next; // n2 -&gt; end &#125; if (n2.next != null) &#123; return n1.next; &#125; else &#123; return n1; &#125; &#125;&#125; 小结 1总结不易，切勿抄袭，帮助你理解是最终目的 欢迎加我QQ：1939765238 一起学习算法","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","permalink":"http://yoursite.com/tags/CSDN迁移/"}]},{"title":"牛客刷题","slug":"牛客刷题","date":"2019-03-03T08:32:47.000Z","updated":"2019-05-14T06:56:48.678Z","comments":true,"path":"2019/03/03/牛客刷题/","link":"","permalink":"http://yoursite.com/2019/03/03/牛客刷题/","excerpt":"","text":"版权声明：wangchong https://blog.csdn.net/wfcn_zyq/article/details/88089768 题目描述 1输入一个链表，输出该链表中倒数第k个结点。 要求 12时间限制：1秒 空间限制：32768K 热度指数：552571本题知识点： 链表 思路 12345将链表遍历一遍，放入栈中，在出栈的时候，k的值减一当k在减为0的时候，即为要求的第k个节点但是有一下几种情况1.k大于链表长度，此时，返回null2.头结点head为空，直接返回null 解法 1234567891011121314151617181920212223242526272829303132333435363738/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/import java.util.Stack;public class Solution &#123; public ListNode FindKthToTail(ListNode head,int k) &#123; Stack&lt;ListNode&gt; stack = new Stack&lt;ListNode&gt;(); ListNode cur = head; while (cur != null) &#123; stack.push(cur); cur = cur.next; &#125; if(k == 1) &#123; return stack.pop(); &#125; while (k-- &gt; 1) &#123; if (stack.size() == 0) &#123; return null; &#125; stack.pop(); &#125; if (k &gt;= 0) &#123; if (stack.size() == 0) &#123; return null; &#125; return stack.pop(); &#125;else &#123; return null; &#125; &#125;&#125;","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","permalink":"http://yoursite.com/tags/CSDN迁移/"}]},{"title":"LeetCode 203. 移除链表元素","slug":"LeetCode 203. 移除链表元素","date":"2019-03-03T05:42:40.000Z","updated":"2019-05-14T06:55:48.446Z","comments":true,"path":"2019/03/03/LeetCode 203. 移除链表元素/","link":"","permalink":"http://yoursite.com/2019/03/03/LeetCode 203. 移除链表元素/","excerpt":"","text":"版权声明：wangchong https://blog.csdn.net/wfcn_zyq/article/details/88087417 题目一描述 1234删除链表中等于给定值 val 的所有节点。示例:输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6输出: 1-&gt;2-&gt;3-&gt;4-&gt;5 Java实现 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; ListNode pre = head; ListNode deNode; for (ListNode cur = head; cur != null;) &#123; if (cur.val == val &amp;&amp; cur == head) &#123; head = head.next; if (head == null) &#123; deNode = cur; cur = head; deNode = null; &#125; else &#123; deNode = cur; cur = head; deNode = null; pre = head; &#125; &#125; else if (cur.val == val) &#123; pre.next = cur.next; cur = pre.next; &#125;else &#123; pre = cur; cur = pre.next; &#125; &#125; return head; &#125;&#125; 运行结果 总结 123消耗内存好像有点多，才击败了0.88%的用户，代码还有需要改进的地方，请各位大佬指正啊后面可能会有更新这个题目，优化一下算法可能原因：使用太多的变量 本人QQ：1939765238 欢迎一起学习的同学来讨论","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","permalink":"http://yoursite.com/tags/CSDN迁移/"}]},{"title":"三天打鱼两天晒网","slug":"三天打鱼两天晒网","date":"2019-03-02T13:52:07.000Z","updated":"2019-05-14T06:56:24.935Z","comments":true,"path":"2019/03/02/三天打鱼两天晒网/","link":"","permalink":"http://yoursite.com/2019/03/02/三天打鱼两天晒网/","excerpt":"","text":"版权声明：wangchong https://blog.csdn.net/wfcn_zyq/article/details/87992161 中国有句俗语叫“三天打鱼两天晒网”。某人从2010年1月1日起开始“三天打鱼两天晒网”，问这个人在以后的某一天中是“打鱼”还是“晒网”。 基本要求： 11.程序风格良好(使用自定义注释模板)，提供友好的输入输出。 提高要求： 1231.输入数据的正确性验证。2.使用文件进行数据测试。如将日期 20100101 20111214 等数据保存在in.txt文件中，程序读入in.dat文件进行判定，并将结果输出至out.txt文件。 分析问题 123456根据题意可以将解题过程分为三步：1)计算从2010年1月1日开始至指定日期共有多少天；2)由于“打鱼”和“晒网”的周期为5天，所以将计算出的天数用5去除；3)根据余数判断他是在“打鱼”还是在“晒网”； 若余数为0，1，2，则他是在“打鱼” 否则是在“晒网” 关键问题 1起始年到指定日期之间存在闰年和平年天数不一样，我们要一一判断 判断平年和闰年 闰年和平年的判断方法 1不是闰年的年份就是平年。 闰年的判断方法： 12345678闰年又分为普通闰年和世纪闰年，普通年判断方法：能被4整除且不能被100整除的为闰年（如2004年就是闰年，1999年不是闰年）。世纪年判断方法：能被400整除的是闰年（如2000年是闰年，1900年不是闰年）。闰年(Leap Year)是为了弥补因人为历法规定造成的年度天数与地球实际公转周期的时间差而设立的。补上时间差的年份为闰年。闰年共有366天（1-12月分别为31天，29天，31天，30天，31天，30天，31天，31天，30天，31天，30天，31天）。 代码实现分析 首先建立日期的结构体 12345private static class date&#123; int year; int month; int day; &#125; 根据题意要实现文件的输入与输出 123456789101112131415161718192021222324252627282930Scanner input = new Scanner(System.in); File inDatFile = new File(&quot;F:\\\\in.dat&quot;); File inTxtFile = new File(&quot;F:\\\\in.txt&quot;); /* 新建两个文件对象* inDatFile 作为从in.dat中读取数据* inTxtFile 作为向in.txt中存储数据*/ Writer inDat = new FileWriter(inDatFile); Writer inTxt = new FileWriter(inTxtFile); //两个Writer对象通过write()函数向对应文件中输入数据 System.out.println(&quot;Please enter eight digits year, month and day.&quot;); System.out.println(&quot;Please input the date begin:&quot;); String beginDate = input.nextLine(); inDat.write(beginDate + &quot;\\r\\n&quot;); inTxt.write(beginDate + &quot;\\r\\n&quot;); /* 输入流输入的同时向文件中存储 并加上\\r\\n使其换行 是为了在读取是一行读取，操作方便 下面的操作相同*/ System.out.println(&quot;Please enter eight digits year, month and day.&quot;); System.out.println(&quot;Please input the date end:&quot;); String endDate = input.nextLine(); inDat.write(endDate + &quot;\\r\\n&quot;); inTxt.write(endDate + &quot;\\r\\n&quot;); inTxt.close(); inDat.close(); 输入数据正确性验证 1234567891011121314151617181920212223242526272829303132333435BufferedReader in = new BufferedReader(new FileReader(&quot;F:\\\\in.dat&quot;));//打开文件创建数据流 //从in.dat中读取开始日期 strInBeginDate = in.readLine(); inBeginDate = Integer.parseInt(strInBeginDate); if (strInBeginDate.length() != 8) &#123; System.out.println(&quot;Date must be 8 digits!&quot;); judge = false; continue; &#125; s = Arrays.copyOf(s,s.length+1); //扩容 如果对内存没有要求可以直接声明一个大容量的数组 s[0] = strInBeginDate.substring(0,8); strInEndDate = in.readLine(); //判断读入长度是否符合年月日规范 if (strInEndDate.length() != 8) &#123; System.out.println(&quot;Date must be 8 digits!&quot;); judge = false; continue;//这一个模块是在一个循环中，不符合条件的要重新输入数据，下同 &#125; in.close(); inEndDate = Integer.parseInt(strInEndDate); s = Arrays.copyOf(s,s.length+1); //扩容 如果对内存没有要求可以直接声明一个大容量的数组 s[1] = strInEndDate.substring(0,8); //初始日期大于终止日期，不符合要求重新输入 if (inBeginDate &gt; inEndDate) &#123; System.out.println(&quot;Begin date must big than end date&quot;); judge = false; continue;//同上 &#125; //判断日期是否为正确的日期时间 if(!(isRightDate(inBeginDate / 10000,inBeginDate / 100 % 100, inBeginDate % 100) &amp;&amp; isRightDate(inEndDate / 10000,inEndDate / 100 % 100,inEndDate % 100))) &#123; System.out.println(&quot;The date is wrong&quot;); judge = false; continue; &#125; 下面是isRightDate()函数 123456789101112private static boolean isRightDate(int year, int month, int day) &#123; int day_tab[][] = &#123;&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;, /*平均每月的天数*/ &#123;0,31,29,31,30,31,30,31,31,30,31,30,31&#125; &#125;; //2019年之后，2019年3月之后还没到，2019年3月2号之后也不符合要求 if (year &gt; 2019 || (year == 2019 &amp;&amp; month &gt; 3) || (year == 2019 &amp;&amp; month == 3 &amp;&amp; day &gt; 2) || (month &gt; 12)) &#123; return false; &#125; int lp = year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0 ? 1 : 0; return day_tab[lp][month] &gt;= day;//判断闰年或者平年，并且对应的月份的天数时候超过最大天数 &#125; 计算从开始日期到指定日期的天数 123456789101112131415161718192021222324252627 date today = new date();//指定日期 date term = new date();//从开始日期到指定日期的变量 int sumDays,year,day; //分割字符串，分出年月日 today.year = Integer.parseInt(s[1].substring(0,4)); today.month = Integer.parseInt(s[1].substring(4,6)); today.day = Integer.parseInt(s[1].substring(6,8)); term.month = 12; /*设置变量的初始值：月*/ term.day = 31; /*设置变量的初始值：日*/ for(sumDays = 0, year = 2010; year &lt; today.year; year++) &#123; term.year = year; sumDays += days(term); /*计算从2010年至指定年的前一年共有多少天*/ &#125; sumDays += days(today); /*加上指定年中到指定日期的天数*/ day = sumDays % 5; /*求余数*///向out.txt输入结果 File outFile = new File(&quot;F:\\\\out.txt&quot;); Writer out = new FileWriter(outFile); if(day &gt;= 0 &amp;&amp; day &lt; 3) &#123; System.out.println(&quot;he was fishing at that day.\\n&quot;); out.write(&quot;he was fishing at that day.\\n&quot;); /*打印结果*/ &#125; else &#123; System.out.println(&quot;He was sleeping at that day.&quot;); out.write(&quot;He was sleeping at that day.\\n&quot;); &#125; out.close(); 下面是用到的days()函数 123456789101112private static int days(date day) &#123;//两个输入代表平年和闰年的天数 int day_tab[][] = &#123;&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;, /*平均每月的天数*/ &#123;0,31,29,31,30,31,30,31,31,30,31,30,31&#125; &#125;; int lp = day.year % 4 == 0 &amp;&amp; day.year % 100 != 0 || day.year % 400 == 0 ? 1 : /*判定year为闰年还是平年，lp=0为平年， 1为闰年*/ for(int i = 1; i &lt; day.month; i++) /*计算本年中自1月1日起的天数*/ day.day += day_tab[lp][i]; return day.day; &#125; 到此为止整个程序完成","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","permalink":"http://yoursite.com/tags/CSDN迁移/"}]},{"title":"C语言实现（小米面试题）给定一个句子（只包含字母,空格，逗号和句号）， 将句子中的单词位置反转，符号不变。（使用指针）","slug":"C语言实现（小米面试题）给定一个句子（只包含字母,空格，逗号和句号）， 将句子中的单词位置反转，符号不变。（使用指针）","date":"2018-11-25T05:35:36.000Z","updated":"2019-05-14T06:55:06.314Z","comments":true,"path":"2018/11/25/C语言实现（小米面试题）给定一个句子（只包含字母,空格，逗号和句号）， 将句子中的单词位置反转，符号不变。（使用指针）/","link":"","permalink":"http://yoursite.com/2018/11/25/C语言实现（小米面试题）给定一个句子（只包含字母,空格，逗号和句号）， 将句子中的单词位置反转，符号不变。（使用指针）/","excerpt":"","text":"版权声明：wangchong https://blog.csdn.net/wfcn_zyq/article/details/84486447 例子 输入： hello xiao.mi 输出： olleh oaix.im 思路:输入一个句子（只包含字母,空格，逗号和句号），指针指向该字符串首地址，遍历字符串找到字符串中非字母处，记下该位置记录到整型数组中，调用反转字符串的数组，利用记下的位置分单词反转。 123456789101112131415161718192021222324252627282930//Dev-Cpp下实现#include &lt;stdio.h&gt;char*fan(char*p,int b[10],int j)&#123; char t; int i; for(i=b[j];i&lt;(b[j+1]+b[j])/2;i++) &#123; t=p[b[j]];p[b[j]]=p[b[j+1]];p[b[j]+1]=t; &#125; return (p);&#125;int main()&#123; char a[100],*p=a; int i,j=1,b[10]=&#123;0&#125;; printf(&quot;输入一个句子（只包含字母,空格，逗号和句号）：\\n&quot;); gets(a); for(i=0;i&lt;100;i++) &#123; if((a[i]&lt;=&apos;z&apos;&amp;&amp;a[i]&gt;=&apos;a&apos;)||(a[i]&gt;=&apos;A&apos;&amp;&amp;a[i]&lt;=&apos;Z&apos;)) continue; else b[j++]=i;//记下除字母外的字符的位置 &#125; for(j=0;j&lt;10;j++) &#123; if(b[j]==0&amp;&amp;b[j+1]==0)break;//没有记下位置的后边的元素默认为0，以此作为结束标志 else fan(a,b,j); &#125; printf(&quot;%s&quot;,p);&#125;","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","permalink":"http://yoursite.com/tags/CSDN迁移/"}]},{"title":"C语言不使用库函数反转字符串","slug":"C语言不使用库函数反转字符串","date":"2018-11-25T05:22:54.000Z","updated":"2019-05-14T06:55:00.625Z","comments":true,"path":"2018/11/25/C语言不使用库函数反转字符串/","link":"","permalink":"http://yoursite.com/2018/11/25/C语言不使用库函数反转字符串/","excerpt":"","text":"版权声明：wangchong https://blog.csdn.net/wfcn_zyq/article/details/84485725 给定一个字符串，当然你也可以自己输入（更改一下语句） 给定：“student a am i” 输出：“i ma a tneduts” 1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main()&#123; int i = 0; int count = 0; char stu[] = &#123; &quot;student a am i&quot; &#125;; char* star = stu; while (*star++) &#123; count++; &#125; star = stu; char* end = stu + count - 1; for (i = 0; star &lt; end; i++) &#123; char temp = *star; *star = *end; *end = temp; end--; star++; &#125; printf(&quot;%s&quot;, stu);&#125;","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","permalink":"http://yoursite.com/tags/CSDN迁移/"}]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2018-11-01T12:10:58.000Z","updated":"2019-05-14T06:56:28.889Z","comments":true,"path":"2018/11/01/我的第一篇博客/","link":"","permalink":"http://yoursite.com/2018/11/01/我的第一篇博客/","excerpt":"","text":"版权声明：wangchong https://blog.csdn.net/wfcn_zyq/article/details/83626134 大家好！我叫王崇，来自西安科技大学，我的专业是计算机类，第一次接触编程是从大学的课程开始的，学习的第一门语言是C语言。上大学之前没接触过计算机方面的知识，但是对计算机方面的知识特别的感兴趣，看到我的课本里面有一本《高级程序语言设计》，就拿出来看了看。自从接触C语言，对其产生了浓厚的兴趣，每天抱着这本书仔细研读，反复的看，很快我就把它看完了。当然，第一遍看，是粗略的，我大概了解了C语言的一些编码规则，了解了C语言能够实现哪些功能，在学长学姐的推荐下，我下载了一个C语言的编译器交Dev-cpp，然后就开始了C语言的编程，开始照着书上的代码敲一敲，慢慢的体会了其中的乐趣，然后通过不断地做题目，不断地查知识开始对C语言有了进一步地了解。 从此喜欢上了编程，我想向学长学长一样进入BAT，做自己想做的工作，拿自己想拿的工资，过自己想要的生活。我打算通过看书+编程练习+查阅资料+不断地解决问题这样一个模式学习编程。并且我打算把每天空闲的时间用来学习编程，我打算每天学习编程的时间能超过3小时，周末每天学习时间能超过8小时。我希望我们坚持学习编程，不要好高骛远从基础做起，我希望我能实现我的目标，做自己所热爱事业。","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","permalink":"http://yoursite.com/tags/CSDN迁移/"}]}]}